{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"general/","title":"General","text":""},{"location":"heat_transfer/","title":"Heat transfer","text":""},{"location":"heat_transfer/#heat_transfer.h_rad","title":"<code>h_rad(eps, T_s, T_rad)</code>","text":"<p>Calculates the radiative heat transfer coefficient between two surfaces</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>Emissivity of the surface</p> required <code>T_s</code> <code>float</code> <p>Temperature of the surface</p> required <code>T_rad</code> <code>float</code> <p>Temperature of the radiating surface</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Radiative heat transfer coefficient</p> Source code in <code>heat_transfer.py</code> <pre><code>def h_rad(eps,T_s,T_rad):\n    \"\"\"Calculates the radiative heat transfer coefficient between two surfaces\n\n    Args:\n        eps (float): Emissivity of the surface\n        T_s (float): Temperature of the surface\n        T_rad (float): Temperature of the radiating surface\n\n    Returns:\n        float: Radiative heat transfer coefficient\"\"\"\n\n    return eps*scc.sigma*(T_s+T_rad)*(T_s**2+T_rad**2)\n</code></pre>"},{"location":"model/","title":"Model","text":""},{"location":"model/#model.Biot","title":"<code>Biot(lambd, k, h, delta)</code>","text":"<p>Calculates the Biot number</p> <p>Parameters:</p> Name Type Description Default <code>lambd</code> <code>float</code> <p>thickness of the material [m]</p> required <code>k</code> <code>float</code> <p>thermal conductivity of the material [W/m/K]</p> required <code>h</code> <code>float</code> <p>heat transfer coefficient [W/m2/K]</p> required <code>delta</code> <code>float</code> <p>width [m]</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Biot number</p> Source code in <code>model.py</code> <pre><code>def Biot(lambd,k,h,delta):\n    \"\"\"Calculates the Biot number\n\n    Args:\n        lambd (float): thickness of the material [m]\n        k (float): thermal conductivity of the material [W/m/K]\n        h (float): heat transfer coefficient [W/m2/K]\n        delta (float): width [m]\n\n    Returns:\n        float: Biot number\"\"\"\n    return ((lambd*h)/k)*(1+lambd/delta)\n</code></pre>"},{"location":"model/#model.Cp","title":"<code>Cp(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the specific heat capacity of the fluid and stores it in var[\"Cp\"]</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def Cp(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the specific heat capacity of the fluid and stores it in var[\"Cp\"]\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\n    \"\"\"\n    T_m = (var[\"T_fluid_in\"]+var[\"T_fluid_out\"])/2 # K\n\n    p_fluid = hyp[\"p_fluid\"] # bar\n    fluid = hyp[\"fluid\"]\n    glycol_rate = hyp[\"glycol_rate\"] # %\n\n    var[\"Cp\"] = PropsSI('C','P', p_fluid*100000, 'T', T_m, f'INCOMP::{fluid}[{glycol_rate}]')\n</code></pre>"},{"location":"model/#model.Fp","title":"<code>Fp(componentSpecs, var)</code>","text":"<p>Calculates the Fp factor and stores it in var[\"Fp\"]</p> <p>$$F_p = \frac{1}{a_3 R_{inter}+h_{rad}R_{inter}+1}$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters    </p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def Fp(componentSpecs, var):\n    \"\"\"Calculates the Fp factor and stores it in var[\"Fp\"]\n\n    $$F_p = \\frac{1}{a_3 R_{inter}+h_{rad}R_{inter}+1}$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters    \n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n\n    R_inter = componentSpecs[\"R_inter\"]\n\n    h_rad = var[\"h_rad\"]\n    a3 = var[\"a3\"]\n\n    Fp = 1/(a3*R_inter+h_rad*R_inter+1)\n    var[\"Fp\"] = Fp\n</code></pre>"},{"location":"model/#model.KTE_Bt","title":"<code>KTE_Bt(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates Ka_Bt, Th_Bt, and Ep_Bt factors and stores them in var[\"Ka_Bt\"], var[\"Th_Bt\"], and var[\"Ep_Bt\"]</p> <p>$$ g_1 = (l_c/R_{inter})(F'-1)b_1 g_2 = (l_c/R_{inter})(F'-1)b_2 g_3 = (l_c/R_{inter})(F'-1)b_3 g_4 = (l_c/R_{inter})(F'-1)b_4 g_5 = l_cF'S^{*}</p> <p>h_1 = (-iota/R_b)b_1 h_2 = (-iota/R_b)b_2 h_3 = (iota/R_b)(1-b_3) h_4 = (-iota/R_b)b_4 h_5 = 0</p> <p>i_1 = -2k_{abs}\\lambda_{abs}m       anh(mL_{af})(b_1/j) i_2 = -2k_{abs}\\lambda_{abs}m       anh(mL_{af})b_2 i_3 = -2k_{abs}\\lambda_{abs}m       anh(mL_{af})b_3 i_4 = -2k_{abs}\\lambda_{abs}m       anh(mL_{af})b_4 i_5 = 2k_{abs}\\lambda_{abs}m        anh(mL_{af})(b/j)</p> <p>\\kappa_{Bt} = g_2+h_2+i_2     heta_{Bt} = -(g_1+h_1+i_1) \\epsilon_{Bt} = (g_3+h_3+i_3)T_{back} + (g_4+h_4+i_4)T_{sky} + (g_5+h_5+i_5) $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def KTE_Bt(componentSpecs,stepConditions,var):\n    \"\"\"Calculates Ka_Bt, Th_Bt, and Ep_Bt factors and stores them in var[\"Ka_Bt\"], var[\"Th_Bt\"], and var[\"Ep_Bt\"]\n\n    $$\n    g_1 = (l_c/R_{inter})*(F'-1)*b_1\n    g_2 = (l_c/R_{inter})*(F'-1)*b_2\n    g_3 = (l_c/R_{inter})*(F'-1)*b_3\n    g_4 = (l_c/R_{inter})*(F'-1)*b_4\n    g_5 = l_c*F'*S^{*}\n\n    h_1 = (-iota/R_b)*b_1\n    h_2 = (-iota/R_b)*b_2\n    h_3 = (iota/R_b)*(1-b_3)\n    h_4 = (-iota/R_b)*b_4\n    h_5 = 0\n\n    i_1 = -2k_{abs}\\lambda_{abs}m\\tanh(mL_{af})(b_1/j)\n    i_2 = -2k_{abs}\\lambda_{abs}m\\tanh(mL_{af})b_2\n    i_3 = -2k_{abs}\\lambda_{abs}m\\tanh(mL_{af})b_3\n    i_4 = -2k_{abs}\\lambda_{abs}m\\tanh(mL_{af})b_4\n    i_5 = 2k_{abs}\\lambda_{abs}m\\tanh(mL_{af})(b/j)\n\n    \\kappa_{Bt} = g_2+h_2+i_2\n    \\theta_{Bt} = -(g_1+h_1+i_1)\n    \\epsilon_{Bt} = (g_3+h_3+i_3)*T_{back} + (g_4+h_4+i_4)*T_{sky} + (g_5+h_5+i_5)  \n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n    lambd_abs = componentSpecs[\"lambd_abs\"]\n    k_abs = componentSpecs[\"k_abs\"]\n    W = componentSpecs[\"W\"]\n    L_af = componentSpecs[\"L_af\"]\n    l_B = componentSpecs[\"l_B\"]\n    l_c = componentSpecs[\"l_c\"]\n    p_int_tube = componentSpecs[\"p_int_tube\"]\n    p_ext_tube = componentSpecs[\"p_ext_tube\"];p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n\n    R_inter = componentSpecs[\"R_inter\"]\n\n    R_b = componentSpecs[\"R_2\"] + 1/(var[\"h_back\"]+var[\"h_rad_back\"])\n    h_fluid = var[\"h_fluid\"]\n\n    T_sky = stepConditions[\"T_sky\"]\n    T_amb = stepConditions[\"T_amb\"]\n    T_back = stepConditions[\"T_back\"]\n\n    C_B = componentSpecs[\"C_B\"]\n\n    #T_PV = var[\"T_PV\"]\n    h_rad = var[\"h_rad\"]\n    S = var[\"S\"]\n    Fprime = var[\"Fp\"]\n\n    j = var[\"j\"]\n    b = var[\"b\"]\n    m = var[\"m\"] \n\n    iota = componentSpecs[\"iota\"]\n\n    # K = b2 * ( -D_tube*Fprime*((l_c/D_tube)*(h_rad+1/R_t)+(iota/D_tube)/(R_b*Fprime))-2*k_abs*lambd_abs*m*math.tanh(m*L_af) )\n    # T = b1 * ( D_tube*Fprime*((l_c/D_tube)*(h_rad+1/R_t)+(iota/D_tube)/(R_b*Fprime))+2*k_abs*lambd_abs*m*math.tanh(m*L_af))\n    # E = D_tube*Fprime*((l_c/D_tube)*(S+h_rad*T_sky+T_amb/R_t)+((iota/D_tube)*(1-b3)*T_back)/(R_b*Fprime))+2*k_abs*lambd_abs*m*math.tanh(m*L_af)*((b/j) - b3*T_back) + (l_c/R_t)*(Fprime-1)*b3*T_back\n\n    b1 = var[\"b1\"]\n    b2 = var[\"b2\"]\n    b3 = var[\"b3\"]\n    b4 = var[\"b4\"]\n\n    # T_PV - T_B \n    # if stepConditions[\"compt\"] &lt;=2:\n    #     g4 = l_c*Fprime*(S+h_rad*T_sky+T_amb/R_t)\n    #     g3 = (l_c/R_inter)*(Fprime-1)*b3\n    #     g2 = (l_c/R_inter)*(Fprime-1)*b2\n    #     g1 = (l_c/R_inter)*(Fprime-1)*b1\n    # else:\n    #     T_abs = var[\"T_abs_mean\"]\n    #     g4 = l_c*(S+h_rad*T_sky+T_amb/R_t + T_abs/R_inter)\n    #     g3 = -(l_c/R_inter)*b3\n    #     g2 = -(l_c/R_inter)*b2\n    #     g1 = -(l_c/R_inter)*b1\n\n    S_star = var[\"S_star\"]\n\n\n    g5 = l_c*Fprime*S_star\n    g4 = (l_c/R_inter)*(Fprime-1)*b4\n    g3 = (l_c/R_inter)*(Fprime-1)*b3\n    g2 = (l_c/R_inter)*(Fprime-1)*b2\n    g1 = (l_c/R_inter)*(Fprime-1)*b1\n\n    # T_B - T_back\n    h5 = 0.\n    h4 = (-iota/R_b)*b4\n    h3 = (iota/R_b)*(1-b3)\n    h2 = (-iota/R_b)*b2\n    h1 = (-iota/R_b)*b1\n\n    # 2q'_absfin\n    i5 = 2*k_abs*lambd_abs*m*math.tanh(m*L_af)*(b/j)\n    i4 = -2*k_abs*lambd_abs*m*math.tanh(m*L_af)*b4\n    i3 = -2*k_abs*lambd_abs*m*math.tanh(m*L_af)*b3\n    i2 = -2*k_abs*lambd_abs*m*math.tanh(m*L_af)*b2\n    i1 = -2*k_abs*lambd_abs*m*math.tanh(m*L_af)*b1\n\n    K =  g2+h2+i2\n    T = -(g1+h1+i1)\n    E = (g3+h3+i3)*T_back + (g4+h4+i4)*T_sky + (g5+h5+i5)\n\n    var[\"Ka_Bt\"] = K\n    var[\"Th_Bt\"] = T\n    var[\"Ep_Bt\"] = E \n</code></pre>"},{"location":"model/#model.KTE_tf","title":"<code>KTE_tf(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates Ka_tf, Th_tf, and Ep_tf factors and stores them in var[\"Ka_tf\"], var[\"Th_tf\"], and var[\"Ep_tf\"]</p> <p>$$ \\kappa_{tf} = \frac{d_2}{\\chi R_B} + \frac{d_0}{\\chi^2} - \frac{1}{\\chi} $$</p> <p>$$     heta_{tf} = 1 - \frac{d_1}{\\chi R_B} $$</p> <p>$$ \\epsilon_{tf} = \frac{d_3}{\\chi R_B}T_{back} + \frac{d_4}{\\chi R_B}T_{sky} + \frac{d_1}{\\chi R_B}T_{back} + \frac{d_0\\gamma}{\\chi}T_{back} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def KTE_tf(componentSpecs,stepConditions,var):\n    \"\"\"Calculates Ka_tf, Th_tf, and Ep_tf factors and stores them in var[\"Ka_tf\"], var[\"Th_tf\"], and var[\"Ep_tf\"]\n\n    $$\n    \\kappa_{tf} = \\frac{d_2}{\\chi R_B} + \\frac{d_0}{\\chi^2} - \\frac{1}{\\chi}\n    $$\n\n    $$\n    \\theta_{tf} = 1 - \\frac{d_1}{\\chi R_B}\n    $$\n\n    $$\n    \\epsilon_{tf} = \\frac{d_3}{\\chi R_B}T_{back} + \\frac{d_4}{\\chi R_B}T_{sky} + \\frac{d_1}{\\chi R_B}T_{back} + \\frac{d_0\\gamma}{\\chi}T_{back}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n\n    Ka_Bt = var[\"Ka_Bt\"]\n    Th_Bt = var[\"Th_Bt\"]\n    Ep_Bt = var[\"Ep_Bt\"]\n\n    b1 = var[\"b1\"]\n    b2 = var[\"b2\"]\n    b3 = var[\"b3\"]\n    b4 = var[\"b4\"]\n\n    d0 = 1/var[\"e0\"]\n    d1 = var[\"d1\"]\n    d2 = var[\"d2\"]\n    d3 = var[\"d3\"]\n    d4 = var[\"d4\"]\n\n    C_B = componentSpecs[\"C_B\"]\n    p_ext_tube = componentSpecs[\"p_ext_tube\"];p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    R_B = 1/(C_B+p_ext_tube_rad*h_rad_tube_abs)\n    p_int_tube = componentSpecs[\"p_int_tube\"]\n    h_fluid = var[\"h_fluid\"]\n    chi = 1/(h_fluid*p_int_tube)\n\n    gamma = calc_gamma(componentSpecs, var)\n\n    T_sky = stepConditions[\"T_sky\"]\n    T_back = stepConditions[\"T_back\"]\n\n    # var[\"Ka_tf\"] = Ka_Bt - (gamma*b2)/c3\n    # var[\"Th_tf\"] = 1/c3 + gamma*b1 + Th_Bt\n    # var[\"Ep_tf\"] = Ep_Bt + gamma*(1-b3)*T_back\n\n    var[\"Ka_tf\"] = d1*b2 + d2 + Ka_Bt\n    var[\"Th_tf\"] = 1 - d1*b1 + Th_Bt\n    # calcul\u00e9 : puis test avec changement des signes ci-dessus\n    #     var[\"Th_tf\"] = 1 - d1*b1 + Th_Bt\n    var[\"Ep_tf\"] = Ep_Bt + (d1*b3 + d3) * T_back + (d1*b4 + d4) * T_sky \n\n    # var[\"Ka_tf\"] = (d0*b2)/(chi*R_B) + (d0/chi**2) - 1/chi\n    # var[\"Th_tf\"] = 1 - (d0*b1)/(chi*R_B)\n    # var[\"Ep_tf\"] = ( (d0*b3)/(chi*R_B) + (d0*gamma)*chi )*T_back\n\n    # tentative de correction\n    var[\"Ka_tf\"] = var[\"Ka_Bt\"] - (var[\"e1\"] * var[\"b2\"] + var[\"e2\"]) * (gamma + var[\"h_rad_tube_sky\"] * componentSpecs[\"p_tube_sky\"])\n    var[\"Th_tf\"] = 1 + var[\"Th_Bt\"] + var[\"e1\"] * var[\"b1\"] * (gamma + var[\"h_rad_tube_sky\"] * componentSpecs[\"p_tube_sky\"])\n    var[\"Ep_tf\"] = var[\"Ep_Bt\"] + (gamma - (var[\"e1\"] * var[\"b3\"] + var[\"e3\"]) * (gamma + var[\"h_rad_tube_sky\"] * componentSpecs[\"p_tube_sky\"])) * stepConditions[\"T_back\"] + (var[\"h_rad_tube_sky\"] * componentSpecs[\"p_tube_sky\"] - (var[\"e1\"] * var[\"b4\"] + var[\"e4\"]) * (gamma + var[\"h_rad_tube_sky\"] * componentSpecs[\"p_tube_sky\"])) * stepConditions[\"T_sky\"]\n</code></pre>"},{"location":"model/#model.S","title":"<code>S(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the net absorbed solar radiation (total absorbed - PV power production) and stores it in var[\"S\"]</p> <p>$$ S =         au_{    heta}G(1-\\eta_{PV}) $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def S(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the net absorbed solar radiation (total absorbed - PV power production) and stores it in var[\"S\"]\n\n    $$\n    S = \\tau_{\\theta}G(1-\\eta_{PV})\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    tau_g = componentSpecs[\"tau_g\"]\n    G = stepConditions[\"G\"]\n\n    #T_PV = var[\"T_PV\"]\n    eta_PV = var[\"eta_PV\"]\n\n    S = tau_g*G*(1-eta_PV)\n\n    var[\"S\"] = S\n</code></pre>"},{"location":"model/#model.S_star","title":"<code>S_star(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the $S^{*}$ factor and stores it in var[\"S_star\"]</p> <p>$$S^{*} = S - a_2 + h_{rad}T_{sky}$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:     None</p> Source code in <code>model.py</code> <pre><code>def S_star(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the $S^{*}$ factor and stores it in var[\"S_star\"]\n\n    $$S^{*} = S - a_2 + h_{rad}T_{sky}$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n    Returns:\n        None\n    \"\"\"\n\n    var[\"S_star\"] = var[\"S\"] - var[\"a2\"] + var[\"h_rad\"]*stepConditions[\"T_sky\"]\n</code></pre>"},{"location":"model/#model.X_celltemp","title":"<code>X_celltemp(componentSpecs, var)</code>","text":"<p>Calculates the X_celltemp factor and stores it in var[\"X_celltemp\"]</p> <p>$$X_{celltemp} = 1+\\Eff_{T}(T_{PV}-T_{ref})$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def X_celltemp(componentSpecs,var):\n    \"\"\"Calculates the X_celltemp factor and stores it in var[\"X_celltemp\"]\n\n    $$X_{celltemp} = 1+\\Eff_{T}(T_{PV}-T_{ref})$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n    Eff_T = componentSpecs[\"Eff_T\"]\n    T_ref = componentSpecs[\"T_ref\"]\n\n    T_PV = var[\"T_PV\"]\n\n    X = 1+Eff_T*(T_PV-T_ref)\n\n    var[\"X_celltemp\"]=X\n</code></pre>"},{"location":"model/#model.a0","title":"<code>a0(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the a0 factor and stores it in var[\"a0\"]</p> <p>$$a_0 = \frac{1}{h_{top}+h_{rad}+1/R_g}\\left(\u0007lpha_g G + h_{top} T_{amb} + h_{rad} T_{sky} ight)$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def a0(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the a0 factor and stores it in var[\"a0\"]\n\n    $$a_0 = \\frac{1}{h_{top}+h_{rad}+1/R_g}\\left(\\alpha_g G + h_{top} T_{amb} + h_{rad} T_{sky}\\right)$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n\n    var[\"a0\"] = (1/(var[\"h_top_g\"]+var[\"h_rad_g\"]+1/componentSpecs[\"R_g\"]))*(componentSpecs[\"alpha_g\"]*stepConditions[\"G\"] + var[\"h_top_g\"]*stepConditions[\"T_amb\"] + var[\"h_rad_g\"]*stepConditions[\"T_sky\"])\n</code></pre>"},{"location":"model/#model.a1","title":"<code>a1(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the a1 factor and stores it in var[\"a1\"]</p> <p>$$a_1 = \frac{1}{h_{top}+h_{rad}+1/R_g}\\left(\frac{1}{R_g} ight)$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def a1(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the a1 factor and stores it in var[\"a1\"]\n\n    $$a_1 = \\frac{1}{h_{top}+h_{rad}+1/R_g}\\left(\\frac{1}{R_g}\\right)$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n\n    var[\"a1\"] = (1/(var[\"h_top_g\"]+var[\"h_rad_g\"]+1/componentSpecs[\"R_g\"]))*(1/componentSpecs[\"R_g\"])\n</code></pre>"},{"location":"model/#model.a2","title":"<code>a2(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the a2 factor and stores it in var[\"a2\"]</p> <p>$$a_2 = -\frac{a_0}{R_g}$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:     None</p> Source code in <code>model.py</code> <pre><code>def a2(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the a2 factor and stores it in var[\"a2\"]\n\n    $$a_2 = -\\frac{a_0}{R_g}$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n    Returns:\n        None\n    \"\"\"\n\n    var[\"a2\"] = - var[\"a0\"]/componentSpecs[\"R_g\"]\n</code></pre>"},{"location":"model/#model.a3","title":"<code>a3(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the a3 factor and stores it in var[\"a3\"]</p> <p>$$a_3 = (1-a_1) \frac{1}{R_g}$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def a3(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the a3 factor and stores it in var[\"a3\"]\n\n    $$a_3 = (1-a_1) \\frac{1}{R_g}$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n\n    a1 = var[\"a1\"]\n    var[\"a3\"] = (1-a1)*(1/componentSpecs[\"R_g\"])\n</code></pre>"},{"location":"model/#model.ab_f","title":"<code>ab_f(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the a_f and b_f factors and stores them in var[\"a_f\"] and var[\"b_f\"]</p> <p>$$ a_f = \frac{N_{harp}}{\\dot{m}C_p}\frac{\\kappa_{tf}}{  heta_{tf}} $$</p> <p>$$ b_f = \frac{N_{harp}}{\\dot{m}C_p}\frac{\\epsilon_{tf}}{        heta_{tf}} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def ab_f(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the a_f and b_f factors and stores them in var[\"a_f\"] and var[\"b_f\"]\n\n    $$\n    a_f = \\frac{N_{harp}}{\\dot{m}C_p}\\frac{\\kappa_{tf}}{\\theta_{tf}}\n    $$\n\n    $$\n    b_f = \\frac{N_{harp}}{\\dot{m}C_p}\\frac{\\epsilon_{tf}}{\\theta_{tf}}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n    N_harp = componentSpecs[\"N_harp\"]\n    mdot = stepConditions[\"mdot\"]\n    Cp = var[\"Cp\"]\n\n    Ka_tf = var[\"Ka_tf\"]\n    Th_tf = var[\"Th_tf\"]\n    Ep_tf = var[\"Ep_tf\"]\n\n    a = (N_harp/(mdot*Cp))*(Ka_tf/Th_tf)\n    b = (N_harp/(mdot*Cp))*(Ep_tf/Th_tf)\n\n    var[\"a_f\"] = a\n    var[\"b_f\"] = b\n</code></pre>"},{"location":"model/#model.b","title":"<code>b(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the b factor and stores it in var[\"b\"]</p> <p>$$ b = S+h_{rad}T_{sky}+\frac{T_{amb}}{R_t}+\frac{T_{back}}{R_bF'}+\frac{h_{rad,f}T_{tube,mean}}{F'} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def b(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the b factor and stores it in var[\"b\"]\n\n    $$\n    b = S+h_{rad}T_{sky}+\\frac{T_{amb}}{R_t}+\\frac{T_{back}}{R_bF'}+\\frac{h_{rad,f}T_{tube,mean}}{F'}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    T_back = stepConditions[\"T_back\"]\n    R_b = componentSpecs[\"R_2\"] + 1/(var[\"h_back\"]+var[\"h_rad_back\"])\n\n    h_rad = var[\"h_rad\"]\n    S = var[\"S\"]\n    Fprime = var[\"Fp\"]\n\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    # if h_rad_tube_abs != 0:\n    #     T_tube_mean = var[\"T_tube_mean\"]\n    #     b = S+h_rad*T_sky+T_amb/R_t+T_back/(R_b*Fprime) + (h_rad_tube_abs*T_tube_mean)/Fprime\n    # else:\n    #     b = S+h_rad*T_sky+T_amb/R_t+T_back/(R_b*Fprime)\n\n    # b = S+h_rad*T_sky+T_amb/R_t+T_back/(R_b*Fprime)\n\n    S_star = var[\"S_star\"]\n\n    b = S_star + T_back/(R_b*Fprime)\n\n\n    if componentSpecs[\"fin_2\"]==1:\n        gamma_int = var[\"gamma_2_int\"]\n\n        b += (gamma_int*T_back)/Fprime\n\n    var[\"b\"] = b\n</code></pre>"},{"location":"model/#model.b1","title":"<code>b1(componentSpecs, var)</code>","text":"<p>Calculates the b1 factor and stores it in var[\"b1\"]</p> <p>$$ b_1 = \frac{1}{C_B + h_{rad,f}p_{ext,tube,rad}}\frac{1}{1-c_2} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def b1(componentSpecs, var):\n    \"\"\"Calculates the b1 factor and stores it in var[\"b1\"]\n\n    $$\n    b_1 = \\frac{1}{C_B + h_{rad,f}p_{ext,tube,rad}}\\frac{1}{1-c_2}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    C_B = componentSpecs[\"C_B\"]  \n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n    p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n\n    e1 = var[\"e1\"]\n    f0 = var[\"f0\"]\n    # print('b1')\n    # print('e1',e1)\n    # print('gamma',gamma)\n\n    var[\"b1\"] = 1/(C_B + h_rad_tube_abs*p_ext_tube_rad - f0*e1)\n</code></pre>"},{"location":"model/#model.b2","title":"<code>b2(componentSpecs, var)</code>","text":"<p>Calculates the b2 factor and stores it in var[\"b2\"]</p> <p>$$ b_2 = \frac{1}{c_0\\chi}\frac{1}{1-c_2} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def b2(componentSpecs, var):\n    \"\"\"Calculates the b2 factor and stores it in var[\"b2\"]\n\n    $$\n    b_2 = \\frac{1}{c_0\\chi}\\frac{1}{1-c_2}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    f0 = var[\"f0\"]\n    e2 = var[\"e2\"]\n    b1 = var[\"b1\"]\n\n    var[\"b2\"] = f0*e2*b1\n</code></pre>"},{"location":"model/#model.b3","title":"<code>b3(componentSpecs, var)</code>","text":"<p>Calculates the b3 factor and stores it in var[\"b3\"]</p> <p>$$ b_3 = -\frac{1}{C_B + h_{rad,f}p_{ext,tube,rad}}\\gamma $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def b3(componentSpecs, var):\n    \"\"\"Calculates the b3 factor and stores it in var[\"b3\"]\n\n    $$\n    b_3 = -\\frac{1}{C_B + h_{rad,f}p_{ext,tube,rad}}\\gamma\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    C_B = componentSpecs[\"C_B\"]  \n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    gamma = calc_gamma(componentSpecs, var)\n\n    e3 = var[\"e3\"]\n    f0 = var[\"f0\"]\n    # c'est v\u00e9rifi\u00e9 c'est \u00e9gal\n    # var[\"b3\"] = (-1/(C_B + h_rad_tube_abs*p_ext_tube_rad))*gamma\n    # var[\"b3\"] =  (-1/(C_B + h_rad_tube_abs*p_ext_tube_rad))*gamma\n\n    var[\"b3\"] = (f0*e3 - gamma)*var[\"b1\"]\n</code></pre>"},{"location":"model/#model.b4","title":"<code>b4(componentSpecs, var)</code>","text":"<p>Calculates the b4 factor and stores it in var[\"b4\"]</p> <p>$$b_4 = b_1(f_0e_4 - h_{rad,tube,sky})$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def b4(componentSpecs, var):\n    \"\"\"Calculates the b4 factor and stores it in var[\"b4\"]\n\n    $$b_4 = b_1(f_0e_4 - h_{rad,tube,sky})$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n\n    b1 = var[\"b1\"]\n    C_B = componentSpecs[\"C_B\"]\n\n    gamma = calc_gamma(componentSpecs, var)\n\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n    p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n    h_rad_tube_sky = var[\"h_rad_tube_sky\"]\n    p_tube_sky = componentSpecs[\"p_tube_sky\"]\n\n    e4 = var[\"e4\"]\n    f0 = var[\"f0\"]\n\n    var[\"b4\"] = b1*(f0*e4 - h_rad_tube_sky*p_tube_sky)\n</code></pre>"},{"location":"model/#model.d1","title":"<code>d1(componentSpecs, var)</code>","text":"<p>Calculates the d1 factor and stores it in var[\"d1\"]</p> <p>$$ d_1 = \frac{1}{c_0\\chi}\frac{1}{1-c_2} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def d1(componentSpecs, var):\n    \"\"\"Calculates the d1 factor and stores it in var[\"d1\"]\n\n    $$\n    d_1 = \\frac{1}{c_0\\chi}\\frac{1}{1-c_2}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    d0 = 1/var[\"e0\"]\n\n    p_int_tube = componentSpecs[\"p_int_tube\"]\n    h_fluid = var[\"h_fluid\"]\n    chi = 1/(h_fluid*p_int_tube)\n\n    gamma = calc_gamma(componentSpecs, var)\n\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n    p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n\n    e1 = var[\"e1\"]\n\n    # var[\"d1\"] = (-gamma*d0)/R_B + h_rad_tube_abs*(1-(d0/R_B))\n    var[\"d1\"] = -e1*(gamma+h_rad_tube_abs*p_ext_tube_rad) + h_rad_tube_abs*p_ext_tube_rad\n</code></pre>"},{"location":"model/#model.d2","title":"<code>d2(componentSpecs, var)</code>","text":"<p>Calculates the d2 factor and stores it in var[\"d2\"]</p> <p>$$ d_2 = \frac{1}{c_0\\chi}\frac{1}{1-c_2} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def d2(componentSpecs, var):\n    \"\"\"Calculates the d2 factor and stores it in var[\"d2\"]\n\n    $$\n    d_2 = \\frac{1}{c_0\\chi}\\frac{1}{1-c_2}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    d0 = 1/var[\"e0\"]\n\n    p_int_tube = componentSpecs[\"p_int_tube\"]\n    h_fluid = var[\"h_fluid\"]\n    chi = 1/(h_fluid*p_int_tube)\n\n    gamma = calc_gamma(componentSpecs, var)\n    p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    # var[\"d2\"] = (-gamma*d0)/chi - (h_rad_tube_abs*d0)/chi\n\n    e2 = var[\"e2\"]\n\n    var[\"d2\"] = -e2*(gamma+h_rad_tube_abs*p_ext_tube_rad)\n</code></pre>"},{"location":"model/#model.d3","title":"<code>d3(componentSpecs, var)</code>","text":"<p>Calculates the d3 factor and stores it in var[\"d3\"]</p> <p>$$ d_3 = \frac{1}{c_0\\chi}\frac{1}{1-c_2} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def d3(componentSpecs, var):\n    \"\"\"Calculates the d3 factor and stores it in var[\"d3\"]\n\n    $$\n    d_3 = \\frac{1}{c_0\\chi}\\frac{1}{1-c_2}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    d0 = 1/var[\"e0\"]\n\n    p_int_tube = componentSpecs[\"p_int_tube\"]\n    h_fluid = var[\"h_fluid\"]\n    chi = 1/(h_fluid*p_int_tube)\n\n    gamma = calc_gamma(componentSpecs, var)\n    p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    # var[\"d3\"] = -gamma**2*d0 + gamma - (h_rad_tube_abs*d0)/(1/gamma)\n\n    e3 = var[\"e3\"]\n    var[\"d3\"] = -e3*(gamma+h_rad_tube_abs*p_ext_tube_rad) + gamma\n</code></pre>"},{"location":"model/#model.d4","title":"<code>d4(componentSpecs, var)</code>","text":"<p>Calculates the d4 factor and stores it in var[\"d4\"]</p> <p>$$d_4 = \frac{1}{c_0\\chi}\frac{1}{1-c_2}$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def d4(componentSpecs, var):\n    \"\"\"Calculates the d4 factor and stores it in var[\"d4\"]\n\n    $$d_4 = \\frac{1}{c_0\\chi}\\frac{1}{1-c_2}$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    gamma = calc_gamma(componentSpecs, var)\n    p_ext_tube_rad  = componentSpecs[\"p_ext_tube_rad\"]\n\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    # var[\"d3\"] = -gamma**2*d0 + gamma - (h_rad_tube_abs*d0)/(1/gamma)\n\n    e4 = var[\"e4\"]\n\n    var[\"d4\"] = -e4*(gamma + h_rad_tube_abs*p_ext_tube_rad)\n</code></pre>"},{"location":"model/#model.e0","title":"<code>e0(componentSpecs, var)</code>","text":"<p>Calculates the e0 factor and stores it in var[\"e0\"]</p> <p>$$ c_0 = \frac{1}{R_{inter}}+\frac{1}{R_bF'}+\frac{h_{rad,f}}{F'} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def e0(componentSpecs, var):\n    \"\"\"Calculates the e0 factor and stores it in var[\"e0\"]\n\n    $$\n    c_0 = \\frac{1}{R_{inter}}+\\frac{1}{R_bF'}+\\frac{h_{rad,f}}{F'}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    p_int_tube = componentSpecs[\"p_int_tube\"]\n    h_fluid = var[\"h_fluid\"]\n    C_B = componentSpecs[\"C_B\"]   \n    chi = 1/(h_fluid*p_int_tube)\n\n    gamma = calc_gamma(componentSpecs, var)\n    p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    h_rad_tube_sky = var[\"h_rad_tube_sky\"]\n    p_tube_sky = componentSpecs[\"p_tube_sky\"]\n\n    # v\u00e9rifier l'homog\u00e9n\u00e9it\u00e9\n    var[\"e0\"] = 1/chi + h_rad_tube_abs*p_ext_tube_rad + C_B + gamma + h_rad_tube_sky*p_tube_sky\n</code></pre>"},{"location":"model/#model.e1","title":"<code>e1(componentSpecs, var)</code>","text":"<p>Calculates the e1 factor and stores it in var[\"e1\"]</p> <p>$$ e_1 = \frac{C_B+p_{ext,tube,rad}h_{rad,f}}{c_0} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def e1(componentSpecs,var):\n    \"\"\"Calculates the e1 factor and stores it in var[\"e1\"]\n\n    $$\n    e_1 = \\frac{C_B+p_{ext,tube,rad}h_{rad,f}}{c_0}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    C_B = componentSpecs[\"C_B\"]\n    p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    e0 = var[\"e0\"]\n\n    var[\"e1\"] = (1/e0)*(C_B+p_ext_tube_rad*h_rad_tube_abs)\n</code></pre>"},{"location":"model/#model.e2","title":"<code>e2(componentSpecs, var)</code>","text":"<p>Calculates the e2 factor and stores it in var[\"e2\"]</p> <p>$$ e_2 = \frac{1}{c_0\\chi} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables </p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def e2(componentSpecs,var):\n    \"\"\"Calculates the e2 factor and stores it in var[\"e2\"]\n\n    $$\n    e_2 = \\frac{1}{c_0\\chi}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables \n\n    Returns:\n        None\"\"\"\n\n    p_int_tube = componentSpecs[\"p_int_tube\"]\n    h_fluid = var[\"h_fluid\"]\n    chi = 1/(h_fluid*p_int_tube)\n\n    e0 = var[\"e0\"]\n\n    var[\"e2\"] = (1/e0)*(1/chi)\n</code></pre>"},{"location":"model/#model.e3","title":"<code>e3(componentSpecs, var)</code>","text":"<p>Calculates the e3 factor and stores it in var[\"e3\"]</p> <p>$$ e_3 = \frac{\\gamma}{c_0} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def e3(componentSpecs,var):\n    \"\"\"Calculates the e3 factor and stores it in var[\"e3\"]\n\n    $$\n    e_3 = \\frac{\\gamma}{c_0}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    gamma = calc_gamma(componentSpecs, var)\n\n    e0 = var[\"e0\"]\n\n    var[\"e3\"] = (1/e0)*gamma\n</code></pre>"},{"location":"model/#model.e4","title":"<code>e4(componentSpecs, var)</code>","text":"<p>Calculates the e4 factor and stores it in var[\"e4\"]</p> <p>$$e_4 = \frac{1}{c_0}h_{rad,tube,sky}$$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def e4(componentSpecs,var):\n    \"\"\"Calculates the e4 factor and stores it in var[\"e4\"]\n\n    $$e_4 = \\frac{1}{c_0}h_{rad,tube,sky}$$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n\n    e0 = var[\"e0\"]\n\n    h_rad_tube_sky = var[\"h_rad_tube_sky\"]\n    p_tube_sky = componentSpecs[\"p_tube_sky\"]\n\n    var[\"e4\"] = (1/e0)*h_rad_tube_sky*p_tube_sky\n</code></pre>"},{"location":"model/#model.eta_PV","title":"<code>eta_PV(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the PV efficiency and stores it in var[\"eta_PV\"]</p> <p>$$ \\eta_{PV} = \\eta_{nom}X_{celltemp}X_{rad}X_{corr} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def eta_PV(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the PV efficiency and stores it in var[\"eta_PV\"]\n\n    $$\n    \\eta_{PV} = \\eta_{nom}X_{celltemp}X_{rad}X_{corr}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    eta_nom = componentSpecs[\"eta_nom\"]\n    G = stepConditions[\"G\"]\n    X_rad = componentSpecs[\"X_rad\"]\n    X_corr = componentSpecs[\"X_corr\"]\n\n    X_celltemp = var[\"X_celltemp\"]\n\n    eta = eta_nom*X_celltemp*X_rad*X_corr\n    var[\"eta_PV\"] = eta\n</code></pre>"},{"location":"model/#model.f0","title":"<code>f0(componentSpecs, var)</code>","text":"<p>Calculates the f0 factor and stores it in var[\"f0\"]</p> <p>$$ f_0 = C_B + h_{rad,f}p_{ext,tube,rad} + \\gamma $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def f0(componentSpecs,var):\n    \"\"\"Calculates the f0 factor and stores it in var[\"f0\"]\n\n    $$\n    f_0 = C_B + h_{rad,f}p_{ext,tube,rad} + \\gamma\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    C_B = componentSpecs[\"C_B\"]\n\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n    p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n\n    h_rad_tube_sky = var[\"h_rad_tube_sky\"]\n    p_tube_sky = componentSpecs[\"p_tube_sky\"]\n\n    gamma = calc_gamma(componentSpecs, var)\n\n    var[\"f0\"] = C_B + h_rad_tube_abs*p_ext_tube_rad + gamma + h_rad_tube_sky*p_tube_sky\n</code></pre>"},{"location":"model/#model.gamma0int","title":"<code>gamma0int(N, L_fin, lambd, k, delta, delta_int, L_tube, h)</code>","text":"<p>Calculates the gamma_0_int factor and returns it</p> <p>$$ \\gamma_{0,int} = \frac{\u0007lpha}{\\lambda}\frac{\\sinh(\u0007lpha L_{fin}/\\lambda)+\beta\u0007lpha/\\lambda\\cosh(\u0007lpha L_{fin}/\\lambda)}{\\cosh(\u0007lpha L_{fin}/\\lambda)+\beta\\sinh(\u0007lpha L_{fin}/\\lambda)} $$</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>number of fins</p> required <code>L_fin</code> <code>float</code> <p>length of the fin</p> required <code>lambd</code> <code>float</code> <p>thickness of the fin</p> required <code>k</code> <code>float</code> <p>thermal conductivity of the fin</p> required <code>delta</code> <code>float</code> <p>width of the fin</p> required <code>delta_int</code> <code>float</code> <p>contact length between the fin and the tube</p> required <code>L_tube</code> <code>float</code> <p>length of the tube</p> required <code>h</code> <code>float</code> <p>heat transfer coefficient</p> required <p>Returns:</p> Name Type Description <code>Bi</code> <code>float</code> <p>Biot number</p> <code>gamma_0_int</code> <code>float</code> <p>gamma_0_int factor</p> Source code in <code>model.py</code> <pre><code>def gamma0int(N,L_fin,lambd,k,delta,delta_int,L_tube,h):\n    \"\"\"Calculates the gamma_0_int factor and returns it\n\n    $$\n    \\gamma_{0,int} = \\frac{\\alpha}{\\lambda}\\frac{\\sinh(\\alpha L_{fin}/\\lambda)+\\beta\\alpha/\\lambda\\cosh(\\alpha L_{fin}/\\lambda)}{\\cosh(\\alpha L_{fin}/\\lambda)+\\beta\\sinh(\\alpha L_{fin}/\\lambda)}\n    $$\n\n    Args:\n        N (int): number of fins\n        L_fin (float): length of the fin\n        lambd (float): thickness of the fin\n        k (float): thermal conductivity of the fin\n        delta (float): width of the fin\n        delta_int (float): contact length between the fin and the tube\n        L_tube (float): length of the tube\n        h (float): heat transfer coefficient\n\n    Returns:\n        Bi (float): Biot number\n        gamma_0_int (float): gamma_0_int factor\"\"\"\n\n    Bi = Biot(lambd,k,h,delta)\n\n    alpha = math.sqrt(2*Bi)\n    beta = math.sqrt(Bi/2)*(1/(1+lambd/delta))\n    arg = (alpha*L_fin)/lambd\n\n    numerateur = (alpha/lambd)*math.sinh(arg) + ((beta*alpha)/lambd)*math.cosh(arg)\n    denominateur = math.cosh(arg) + beta*math.sinh(arg)\n\n    return Bi,k*(numerateur/denominateur)*((lambd*N*delta_int)/L_tube)\n</code></pre>"},{"location":"model/#model.gamma1int","title":"<code>gamma1int(N, L_fin, lambd, k, delta, delta_int, L_tube, h)</code>","text":"<p>Calculates the gamma_1_int factor and returns it</p> <p>$$ \\gamma_{1,int} = \frac{\u0007lpha}{\\lambda}\frac{\\sinh(\u0007lpha L_{fin}/\\lambda)}{\\cosh(\u0007lpha L_{fin}/\\lambda)} $$</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>number of fins</p> required <code>L_fin</code> <code>float</code> <p>length of the fin</p> required <code>lambd</code> <code>float</code> <p>thickness of the fin</p> required <code>k</code> <code>float</code> <p>thermal conductivity of the fin</p> required <code>delta</code> <code>float</code> <p>width of the fin</p> required <code>delta_int</code> <code>float</code> <p>contact length between the fin and the tube</p> required <code>L_tube</code> <code>float</code> <p>length of the tube</p> required <code>h</code> <code>float</code> <p>heat transfer coefficient</p> required <p>Returns:</p> Name Type Description <code>Bi</code> <code>float</code> <p>Biot number</p> <code>gamma_1_int</code> <code>float</code> <p>gamma_1_int factor</p> Source code in <code>model.py</code> <pre><code>def gamma1int(N,L_fin,lambd,k,delta,delta_int,L_tube,h):\n    \"\"\"Calculates the gamma_1_int factor and returns it\n\n    $$\n    \\gamma_{1,int} = \\frac{\\alpha}{\\lambda}\\frac{\\sinh(\\alpha L_{fin}/\\lambda)}{\\cosh(\\alpha L_{fin}/\\lambda)}\n    $$\n\n    Args:\n        N (int): number of fins\n        L_fin (float): length of the fin\n        lambd (float): thickness of the fin\n        k (float): thermal conductivity of the fin\n        delta (float): width of the fin\n        delta_int (float): contact length between the fin and the tube\n        L_tube (float): length of the tube\n        h (float): heat transfer coefficient\n\n    Returns:\n        Bi (float): Biot number\n        gamma_1_int (float): gamma_1_int factor\"\"\"\n\n    Bi = Biot(lambd,k,h,delta)\n\n    return Bi,2*k*((lambd*N*delta_int)/L_tube)*math.tanh(math.sqrt(2*Bi)*(L_fin/lambd))*(math.sqrt(2*Bi)/lambd)\n</code></pre>"},{"location":"model/#model.gamma_0_int","title":"<code>gamma_0_int(componentSpecs, var)</code>","text":"<p>Calculates the gamma_0_int factor and stores it in var[\"gamma_0_int\"]</p> Source code in <code>model.py</code> <pre><code>def gamma_0_int(componentSpecs,var):\n    \"\"\"Calculates the gamma_0_int factor and stores it in var[\"gamma_0_int\"]\"\"\"\n\n    var[\"Bi_f0\"],var[\"gamma_0_int\"] = gamma0int(componentSpecs[\"N_f0\"],componentSpecs[\"L_f0\"],componentSpecs[\"lambd_ail\"],componentSpecs[\"k_ail\"],componentSpecs[\"delta_f0\"],componentSpecs[\"delta_f0_int\"],componentSpecs[\"L_tube\"],var[\"h_back_fins\"])\n</code></pre>"},{"location":"model/#model.j","title":"<code>j(componentSpecs, var)</code>","text":"<p>Calculates the j factor and stores it in var[\"j\"]</p> <p>$$ j = \frac{1}{R_{inter}F'}+\frac{1}{R_bF'}-\frac{1}{R_{inter}}+\frac{h_{rad,f}}{F'} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def j(componentSpecs,var):\n    \"\"\"Calculates the j factor and stores it in var[\"j\"]\n\n    $$\n    j = \\frac{1}{R_{inter}F'}+\\frac{1}{R_bF'}-\\frac{1}{R_{inter}}+\\frac{h_{rad,f}}{F'}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    R_inter = componentSpecs[\"R_inter\"]\n    R_b = componentSpecs[\"R_2\"] + 1/(var[\"h_back\"]+var[\"h_rad_back\"])\n    h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    Fprime = var[\"Fp\"]\n\n    j = 1/(Fprime*R_b) + 1/(R_inter*Fprime) - 1/R_inter\n\n    if componentSpecs[\"fin_2\"] == 1:\n\n        gamma_int = var[\"gamma_2_int\"]\n\n        j += (gamma_int)/Fprime\n\n    var[\"j\"] = j\n</code></pre>"},{"location":"model/#model.m","title":"<code>m(componentSpecs, var)</code>","text":"<p>Calculates the m factor and stores it in var[\"m\"]</p> <p>$$ m = \\sqrt{\frac{F'j}{k_{abs}\\lambda_{abs}}} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def m(componentSpecs, var):\n    \"\"\"Calculates the m factor and stores it in var[\"m\"]\n\n    $$\n    m = \\sqrt{\\frac{F'j}{k_{abs}\\lambda_{abs}}}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    lambd_abs = componentSpecs[\"lambd_abs\"]\n    k_abs = componentSpecs[\"k_abs\"]\n\n    Fprime = var[\"Fp\"]\n\n    j = var[\"j\"]\n\n    m = math.sqrt((Fprime*j)/(k_abs*lambd_abs))\n\n    var[\"m\"] = m\n</code></pre>"},{"location":"model/#model.one_loop","title":"<code>one_loop(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Procedure which calculates the variables for one loop</p> <p>\\enumerate{     \\item gamma_{0,int}, gamma_{1,int}, gamma_{2,int}, Bi_{f3}     \\item h_{rad,g}, h_{rad}, h_{top,mean}     \\item a_0, a_1, a_3, a_2     \\item X_{celltemp}, eta_{PV}, S, and S^{*}     \\item F', j, m, b     \\item c_0, c_2, e_1, e_2, e_3, e_4, f_0, b_1, b_2, b_3, b_4     \\item \\kappa_{Bt},      heta_{Bt}, \\epsilon_{Bt}     \\item d_1, d_2, d_3, d_4     \\item \\kappa_{tf},      heta_{tf}, \\epsilon_{tf}     \\item a_f and b_f     \\item T_{fluid,out}     \\item q_{tube-fluid}     \\item \\overline{T_{fluid}}     \\item \\overline{T_{Base}}     \\item \\overline{T_{tube}}     \\item \\overline{T_{absfin}}     \\item \\overline{T_{abs}}     \\item Qdot_{tube-back}     \\item Qdot_{absfin-back}     \\item \\overline{T_{ins-tube}}     \\item \\overline{T_{ins-absfin}}     \\item \\overline{T_{ins}}     \\item Qdot_{ins,conv}     \\item Qdot_{ins,rad}     \\item h_{back,mean}, h_{rad,back}, h_{back,tube}, h_{rad,tube-sky}, h_{rad,back-tube}, h_{back,fins}, h_{rad,f}     \\item \\overline{T_{PV}}, \\overline{T_{PV,Base}}, \\overline{T_{PV,absfin}}     \\item mtemp.T_glass_mean()     \\item mtr.qp_PV_Base()     \\item mtr.qp_Base_back()     \\item mtr.qp_fin()     \\item Cp() }</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>T_fluid_in</code> <code>float</code> <p>fluid inlet temperature</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypothesis</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model.py</code> <pre><code>def one_loop(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Procedure which calculates the variables for one loop\n\n    \\enumerate{\n        \\item gamma_{0,int}, gamma_{1,int}, gamma_{2,int}, Bi_{f3}\n        \\item h_{rad,g}, h_{rad}, h_{top,mean}\n        \\item a_0, a_1, a_3, a_2\n        \\item X_{celltemp}, eta_{PV}, S, and S^{*}\n        \\item F', j, m, b\n        \\item c_0, c_2, e_1, e_2, e_3, e_4, f_0, b_1, b_2, b_3, b_4\n        \\item \\kappa_{Bt}, \\theta_{Bt}, \\epsilon_{Bt}\n        \\item d_1, d_2, d_3, d_4\n        \\item \\kappa_{tf}, \\theta_{tf}, \\epsilon_{tf}\n        \\item a_f and b_f\n        \\item T_{fluid,out}\n        \\item q_{tube-fluid}\n        \\item \\overline{T_{fluid}}\n        \\item \\overline{T_{Base}}\n        \\item \\overline{T_{tube}}\n        \\item \\overline{T_{absfin}}\n        \\item \\overline{T_{abs}}\n        \\item Qdot_{tube-back}\n        \\item Qdot_{absfin-back}\n        \\item \\overline{T_{ins-tube}}\n        \\item \\overline{T_{ins-absfin}}\n        \\item \\overline{T_{ins}}\n        \\item Qdot_{ins,conv}\n        \\item Qdot_{ins,rad}\n        \\item h_{back,mean}, h_{rad,back}, h_{back,tube}, h_{rad,tube-sky}, h_{rad,back-tube}, h_{back,fins}, h_{rad,f}\n        \\item \\overline{T_{PV}}, \\overline{T_{PV,Base}}, \\overline{T_{PV,absfin}}\n        \\item mtemp.T_glass_mean()\n        \\item mtr.qp_PV_Base()\n        \\item mtr.qp_Base_back()\n        \\item mtr.qp_fin()\n        \\item Cp()\n    }\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        T_fluid_in (float): fluid inlet temperature\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypothesis\n\n    Returns:\n        None\"\"\"\n\n    if componentSpecs[\"fin_0\"] == 1:\n        gamma_0_int(componentSpecs,var)\n    else:\n        var[\"gamma_0_int\"] = 0\n    if componentSpecs[\"fin_1\"] == 1:\n        gamma_1_int(componentSpecs,var)\n    else:\n        var[\"gamma_1_int\"] = 0\n    if componentSpecs[\"fin_2\"] == 1:\n        gamma_2_int(componentSpecs,var)\n    else:\n        var[\"gamma_2_int\"] = 0\n    if componentSpecs[\"fin_3\"] == 1:\n        Bi_f3(componentSpecs,var)\n    else:\n        pass\n\n    mht.h_rad_g(componentSpecs,stepConditions,var,hyp)\n    mht.h_rad(componentSpecs,stepConditions,var,hyp)\n\n    if componentSpecs[\"fin_0\"] == 1 or componentSpecs[\"fin_1\"] == 1 or componentSpecs[\"fin_2\"] == 1:\n        mht.h_top_mean(componentSpecs,stepConditions,var,hyp)\n    else:\n        mht.h_top_g(componentSpecs,stepConditions,var,hyp)\n\n    a0(componentSpecs,stepConditions,var)\n    a1(componentSpecs,stepConditions,var)\n    a3(componentSpecs,stepConditions,var)\n    a2(componentSpecs,stepConditions,var)\n\n\n    X_celltemp(componentSpecs,var)\n    eta_PV(componentSpecs,stepConditions,var)\n    S(componentSpecs,stepConditions,var)\n    S_star(componentSpecs,stepConditions,var)\n    Fp(componentSpecs,var)\n    j(componentSpecs,var)\n    m(componentSpecs,var)\n    b(componentSpecs,stepConditions,var)\n\n    e0(componentSpecs,var)\n    e1(componentSpecs,var)\n    e2(componentSpecs,var)\n    e3(componentSpecs,var)\n    e4(componentSpecs,var)\n\n    f0(componentSpecs,var)\n    b1(componentSpecs,var)\n    b2(componentSpecs,var)\n    b3(componentSpecs,var)\n    b4(componentSpecs,var)\n\n    KTE_Bt(componentSpecs,stepConditions,var)\n\n    d1(componentSpecs,var)\n    d2(componentSpecs,var)\n    d3(componentSpecs,var)\n    d4(componentSpecs,var)\n\n    KTE_tf(componentSpecs,stepConditions,var)\n\n    ab_f(componentSpecs,stepConditions,var)\n    mtemp.T_fluid_out(componentSpecs,var)\n    mtr.q_tube_fluid(componentSpecs,stepConditions,var)\n    mtemp.T_fluid_mean(componentSpecs,var)\n    mtemp.T_Base_mean(componentSpecs,stepConditions,var)\n    mtemp.T_tube_mean(componentSpecs,stepConditions,var)\n    mtemp.T_absfin_mean(componentSpecs,stepConditions,var)\n    mtemp.T_abs_mean(componentSpecs,var)\n\n\n    mtr.Qdot_tube_back(componentSpecs,stepConditions,var)\n    mtr.Qdot_absfin_back(componentSpecs,stepConditions,var)   \n    mtemp.T_ins_tube_mean(componentSpecs,var)\n    mtemp.T_ins_absfin_mean(componentSpecs,var)\n    mtemp.T_ins_mean(componentSpecs,var)\n\n    mtr.Qdot_ins_conv(componentSpecs,stepConditions,var)\n    mtr.Qdot_ins_rad(componentSpecs,stepConditions,var)\n\n    if hyp[\"calc_h_back_mean\"]==1:\n        mht.h_back_mean(componentSpecs,stepConditions,var,hyp)\n    else:\n        mht.h_back_abs(componentSpecs,stepConditions,var,hyp)\n\n    mht.h_rad_back(componentSpecs,stepConditions,var,hyp)\n    mht.h_back_tube(componentSpecs,stepConditions,var,hyp)\n    mht.h_rad_tube_sky(componentSpecs,stepConditions,var,hyp)\n    mht.h_rad_back_tube(componentSpecs,stepConditions,var,hyp)\n    mht.h_back_fins(componentSpecs,stepConditions,var,hyp)\n\n    mht.h_rad_tube_abs(componentSpecs,stepConditions,var,hyp)\n\n    mtemp.T_PV_mean(componentSpecs,stepConditions,var)\n    mtemp.T_PV_Base_mean(componentSpecs,stepConditions,var)\n    mtemp.T_PV_absfin_mean(componentSpecs,var)\n    mtemp.T_glass_mean(componentSpecs,stepConditions,var)\n\n    mtr.qp_PV_Base(componentSpecs,var)\n    mtr.qp_Base_back(componentSpecs,stepConditions,var)\n    mtr.qp_fin(componentSpecs,var)\n\n    Cp(componentSpecs,stepConditions,var,hyp)\n</code></pre>"},{"location":"model/#model.simu_one_steady_state","title":"<code>simu_one_steady_state(componentSpecs, stepConditions, hyp)</code>","text":"<p>Procedure which calculates the variables for one steady state</p> <p>\\enumerate{     \\item Initialize the var dictionary with all necessary keys and values     \\item Loop until convergence is reached     \\item Update heat transfer coefficients     \\item Calculate the power balance     \\item Update the fluid inlet temperature     \\item Append the current iteration to the list of iterations     }</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypothesis</p> required <p>Returns:</p> Name Type Description <code>slices_df</code> <code>DataFrame</code> <p>dataframe containing the variables for each slice of the panel</p> <code>df_one</code> <code>DataFrame</code> <p>dataframe containing the variables for the last iteration</p> <code>its_data_list</code> <code>list</code> <p>list of dataframes containing the variables for each iteration</p> Source code in <code>model.py</code> <pre><code>def simu_one_steady_state(componentSpecs, stepConditions, hyp):\n    \"\"\"Procedure which calculates the variables for one steady state\n\n    \\enumerate{\n        \\item Initialize the var dictionary with all necessary keys and values\n        \\item Loop until convergence is reached\n        \\item Update heat transfer coefficients\n        \\item Calculate the power balance\n        \\item Update the fluid inlet temperature\n        \\item Append the current iteration to the list of iterations\n        }\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        hyp (dict): dictionary containing the hypothesis\n\n    Returns:\n        slices_df (DataFrame): dataframe containing the variables for each slice of the panel\n        df_one (DataFrame): dataframe containing the variables for the last iteration\n        its_data_list (list): list of dataframes containing the variables for each iteration\n    \"\"\"\n\n    N_meander = componentSpecs[\"N_meander\"]\n    N_harp = componentSpecs[\"N_harp\"]\n    slices_data = []\n    its_data_list = []\n\n    var = {}\n\n    for i in range(N_meander):\n        var = initialize_var(var, componentSpecs, stepConditions, hyp, i)\n        compt = 0\n        stepConditions[\"compt\"] = compt\n        its_data = []\n\n        while compt &lt;= 3 or abs(var[\"T_PV\"] - var[\"T_PV0\"]) &gt;= 0.01:\n\n            if compt &gt; 1000:\n                raise ValueError(\"Convergence not reached\")\n\n            compt += 1\n            stepConditions[\"compt\"] = compt\n\n            one_loop(componentSpecs, stepConditions, var, hyp)\n            compute_power(componentSpecs, stepConditions, var)\n\n            row_data = {**{'G': stepConditions[\"G\"], 'Gp': stepConditions[\"Gp\"],'T_amb': stepConditions[\"T_amb\"], 'T_sky': stepConditions['T_sky'], 'T_back':stepConditions['T_back'], 'T_back_rad':stepConditions['T_back_rad'], 'u': stepConditions['u'],\n                           'mdot': stepConditions['mdot'],'T_fluid_in':stepConditions['T_fluid_in0']}, **var}\n            its_data.append(row_data)\n\n        # Append only once after the loop\n        its_data_list.append(pd.DataFrame(its_data))\n\n        slices_data.append(its_data[-1])\n\n    slices_df = pd.DataFrame(slices_data)\n    df_mean = slices_df.mean()\n    df_sum = slices_df.sum()\n    df_one = pd.DataFrame()\n\n    for key in slices_df.keys():\n        if key in ['mdot','G','Gp','T_amb','T_sky','T_back','T_back_rad','u']:\n            df_one[key] = [stepConditions[key]]\n        elif key == \"T_fluid_in\":\n            df_one[key] = [stepConditions[\"T_fluid_in0\"]]\n        elif key == \"T_fluid_out\":\n            df_one[key] = [slices_df[\"T_fluid_out\"].iloc[-1]]\n        elif key in mean_list:\n            df_one[key] = [df_mean[key]]\n        elif key in add_list:\n            df_one[key] = [df_sum[key]*N_harp]\n\n    return slices_df, df_one, its_data_list\n</code></pre>"},{"location":"model_ht/","title":"Mode heat transfer","text":""},{"location":"model_ht/#model_ht.h_back_abs","title":"<code>h_back_abs(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the convective heat transfer coefficient between the absorber and the ambient air and stores it var[\"h_back\"]</p> <ul> <li> <p>If the component is an anomaly, the coefficient is the same as the one found when solving the 'main'</p> </li> <li> <p>If the component is a manifold:</p> <ul> <li> <p>The characteristic length L_c is the height of the tube H_tube</p> </li> <li> <p>If the method is 'free_cylinder', the coefficient is calculated with the free convection coefficient for a cylinder</p> </li> <li>If the method is 'like_exchanger', the coefficient is the same as the one found when solving the 'main'</li> </ul> </li> <li> <p>If the component is a heat exchanger part:</p> <ul> <li> <p>The characteristic length L_c is the length of the absorber L_abs if the orientation is 'portrait', otherwise it is the width of the absorber w_abs</p> </li> <li> <p>If the component has fins:</p> <ul> <li>If the number of fins is less than 24, the coefficient is calculated with the free convection coefficient for a simple geometry</li> <li>If the number of fins is greater than 24, the coefficient is calculated with the free convection coefficient for a finned geometry</li> </ul> </li> <li> <p>If the component has no fins:</p> <ul> <li>If the method is 'free_with_coeff', the coefficient is the free convection coefficient multiplied by a coefficient</li> <li>If the method is 'free', the coefficient is the free convection coefficient</li> <li>If the method is 'mixed', the coefficient is the mixed convection coefficient</li> </ul> </li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters of the PVT panel</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_back_abs(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the convective heat transfer coefficient between the absorber and the ambient air and stores it var[\"h_back\"]\n\n    - If the component is an anomaly, the coefficient is the same as the one found when solving the 'main'\n\n    - If the component is a manifold:\n\n        - The characteristic length L_c is the height of the tube H_tube\n\n        - If the method is 'free_cylinder', the coefficient is calculated with the free convection coefficient for a cylinder\n        - If the method is 'like_exchanger', the coefficient is the same as the one found when solving the 'main'\n\n    - If the component is a heat exchanger part:\n\n        - The characteristic length L_c is the length of the absorber L_abs if the orientation is 'portrait', otherwise it is the width of the absorber w_abs\n\n        - If the component has fins:\n\n            - If the number of fins is less than 24, the coefficient is calculated with the free convection coefficient for a simple geometry\n            - If the number of fins is greater than 24, the coefficient is calculated with the free convection coefficient for a finned geometry\n\n        - If the component has no fins:\n\n            - If the method is 'free_with_coeff', the coefficient is the free convection coefficient multiplied by a coefficient\n            - If the method is 'free', the coefficient is the free convection coefficient\n            - If the method is 'mixed', the coefficient is the mixed convection coefficient\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters of the PVT panel\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\"\"\"\n\n    if hyp['method_h_back_abs'] == 'CFD':\n        get_CFD_value(componentSpecs, stepConditions, var, hyp, 'h_back', 'phi_abs', 'T_abs_mean', 'T_amb')\n        return\n\n    # Anomaly\n    # If this part of the PVT is an anomaly in the sif this part of the PVT is an anomaly in the sense that the exchanger\n    # is detached from the PV over a short distance, the transfer coefficient at the absorber (which in this case is the PV backsheet)\n    # is taken as that calculated for the \u201cmain\u201d.\n\n    if  componentSpecs[\"is_anomaly\"] == 1:\n\n        if hyp['method_h_back_anomaly'] == \"like_exchanger\":\n            var[\"h_back\"] = hyp['h_back_prev']\n        else:\n            raise ValueError(\"Method for h_back is not well defined for anomalies\")\n\n    # Manifold\n    # If this part of the PVT is a manifold, the transfer coefficient at the absorber is taken as:\n    # - that calculated from the correlation for a free cylinder\n    # - or that for the \u201cmain\u201d.\n    elif componentSpecs[\"is_inlet_man\"] == 1 or componentSpecs[\"is_outlet_man\"] == 1 :\n\n        L_c = componentSpecs['H_tube']\n\n        if componentSpecs[\"insulated\"] == 1:\n            T_ref = var[\"T_ins_mean\"]    \n        else:\n            T_ref = var[\"T_abs_mean\"]\n\n        if hyp['method_h_back_manifold'] == \"free_cylinder\":\n                # res = bht.back_h_mixed(T_ref,stepConditions[\"T_back\"],stepConditions[\"u_back\"],hyp[\"theta\"],L_c)\n            var[\"h_back\"] = bht.back_h_cylinder(T_ref,stepConditions[\"T_back\"],L_c)\n\n        elif hyp['method_h_back_manifold'] == \"like_exchanger\":\n            var[\"h_back\"] = hyp['h_back_prev']\n\n        else:\n            raise ValueError(\"Method for h_back is not well defined for manifolds\")\n\n    # Heat exchanger \n    else:\n\n        # Parameters\n\n        if componentSpecs[\"orientation\"] == 'portrait':\n            L_c = componentSpecs[\"L_abs\"]\n        else:\n            L_c = componentSpecs[\"w_abs\"]\n\n        # If error\n        if var[\"T_abs_mean\"]==None:\n            print('T_abs_mean = None in h_back_abs()')\n            var[\"h_back\"] = 0.5\n\n        # Case with fins\n        elif componentSpecs[\"fin_0\"] &gt;= 1 or componentSpecs[\"fin_1\"] &gt;= 1 or componentSpecs[\"fin_2\"] &gt;= 1:\n\n            D = componentSpecs[\"D\"]\n\n            if componentSpecs[\"N_ail\"]&lt;= 24:\n                var[\"h_back\"] = hyp[\"coeff_h_back\"]*bht.back_h_simple(var[\"T_abs_mean\"],stepConditions[\"T_back\"],hyp[\"theta\"],L_c)\n            else:\n                print('here')\n                var[\"h_back\"] = 1/(1/(hyp[\"coeff_h_back\"]*bht.back_h_fins(var[\"T_abs_mean\"],stepConditions[\"T_back\"],hyp[\"theta\"],L_c,D,componentSpecs[\"Heta\"]))+0.01)\n\n        # Cas without fins\n        else:\n            # theta est l'inclinaison du panneau componentSpecs rapport \u00e0 l'horizontale\n\n            if componentSpecs[\"insulated\"] == 1:\n                T_ref = var[\"T_ins_mean\"]\n            else:\n                T_ref = var[\"T_abs_mean\"]\n\n            if hyp['method_h_back_abs'] == \"free_with_coeff\": \n                var[\"h_back\"] = hyp[\"coeff_h_back\"]*bht.back_h_simple(T_ref,stepConditions[\"T_back\"],hyp[\"theta\"],L_c)\n            elif hyp['method_h_back_abs'] == \"free\":\n                var[\"h_back\"] = bht.back_h_simple(T_ref,stepConditions[\"T_back\"],hyp[\"theta\"],L_c)\n            elif hyp['method_h_back_abs'] == \"mixed\":\n                var[\"h_back\"] = bht.back_h_mixed(T_ref,stepConditions[\"T_back\"],stepConditions[\"u_back\"],hyp[\"theta\"],L_c)\n</code></pre>"},{"location":"model_ht/#model_ht.h_back_fins","title":"<code>h_back_fins(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the back heat transfer coefficient for the fins and stores it in var[\"h_back_fins\"]</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_back_fins(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the back heat transfer coefficient for the fins and stores it in var[\"h_back_fins\"]\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\"\"\"\n\n\n\n    if hyp[\"h_back_fins_calc\"] == \"tube\":\n        var[\"h_back_fins\"] = var[\"h_back_tube\"]\n    elif hyp[\"h_back_fins_calc\"] == \"abs\":\n        var[\"h_back_fins\"] = var[\"h_back\"]\n    elif hyp[\"h_back_fins_calc\"] == \"TS\":\n        L_c = componentSpecs[\"L_fin\"]\n        D = componentSpecs[\"D\"]\n        h_free = hyp[\"coeff_h_back_fins_free\"]*bht.back_h_fins(var[\"T_tube_mean\"],stepConditions[\"T_back\"],hyp[\"theta\"],L_c,D,componentSpecs[\"Heta\"])\n        # h_free = 0.\n        h_forced = hyp[\"coeff_h_back_fins_forced\"]*bht.ht_fins_forced_wiki(componentSpecs[\"L_fin\"],componentSpecs[\"D\"],stepConditions[\"u_back\"]+0.9*stepConditions[\"u\"])\n        var[\"h_back_fins\"] = (h_free**3 + h_forced**3)**(1/3) + hyp[\"offset_h_back_fins\"]\n    else:\n        pass\n</code></pre>"},{"location":"model_ht/#model_ht.h_back_mean","title":"<code>h_back_mean(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the mean h_back between the value at iteration n-1 and the value calculated at iteration n and stores it in var[\"h_back\"]</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:     None</p> Source code in <code>model_ht.py</code> <pre><code>def h_back_mean(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the mean h_back between the value at iteration n-1 and the value calculated at iteration n and stores it in var[\"h_back\"]\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n    Returns:\n        None\n    \"\"\"\n\n    old_h_back = var[\"h_back\"]\n    h_back_abs(componentSpecs,stepConditions,var,hyp)\n\n    new_h_back = var[\"h_back\"]\n\n    var[\"h_back\"] = (old_h_back+new_h_back)/2\n</code></pre>"},{"location":"model_ht/#model_ht.h_back_tube","title":"<code>h_back_tube(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the back heat transfer coefficient for the tube and stores it in var[\"h_back_tube\"]</p> <ul> <li>If the tube is well connected to the absorber (conductive), the coefficient is the same as the back heat transfer coefficient for the absorber</li> <li> <p>If not,</p> <ul> <li>the characteristic length is the height of the tube H_tube</li> <li>if it is a manifold and hyp['inlet_manifold_in_wind'] == 1, the coefficient is calculated as the cubic mean of ht.conv_external and the free convection coefficient for a cylinder</li> <li>if not, the coefficient is calculated with the free convection coefficient for a cylinder</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_back_tube(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the back heat transfer coefficient for the tube and stores it in var[\"h_back_tube\"]\n\n    - If the tube is well connected to the absorber (conductive), the coefficient is the same as the back heat transfer coefficient for the absorber\n    - If not,\n\n        - the characteristic length is the height of the tube H_tube\n        - if it is a manifold and hyp['inlet_manifold_in_wind'] == 1, the coefficient is calculated as the cubic mean of ht.conv_external and the free convection coefficient for a cylinder\n        - if not, the coefficient is calculated with the free convection coefficient for a cylinder\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\"\"\"\n\n    if hyp['method_h_back_tube'] == 'CFD':\n        get_CFD_value(componentSpecs, stepConditions, var, hyp, 'h_back_tube', 'phi_tube', 'T_tube_mean', 'T_amb')\n        return\n\n    # Cas o\u00f9 le tuyau est bien li\u00e9 \u00e0 l'absorbeur (conductif)\n    if componentSpecs[\"l_c\"] &gt; 0. :\n        var[\"h_back_tube\"] = var[\"h_back\"]\n\n    # Cas o\u00f9 le tuyau est d\u00e9coll\u00e9 de l'\u00e9changeur (radiatif seul)\n    # Alors on calcule dans tous les cas comme si c'\u00e9tait unn tube cylindrique\n    else:\n\n        L_c = componentSpecs['H_tube']\n\n        if componentSpecs[\"insulated\"] == 1 and stepConditions[\"compt\"] &gt;= 1:\n\n            T_ref = var[\"T_ins_tube_mean\"]\n\n        else:\n            T_ref = var[\"T_tube_mean\"]\n\n        res = bht.back_h_cylinder(T_ref,stepConditions[\"T_back\"],L_c)\n\n        if componentSpecs[\"is_inlet_man\"] == 1 and hyp[\"inlet_manifold_in_wind\"] == 1:\n            T_film = (var[\"T_tube_mean\"]+stepConditions[\"T_amb\"])/2\n            D = componentSpecs[\"D_tube\"]+componentSpecs[\"lambd_riser_back\"]\n            nu = bht.air_nu(T_film)\n            Re = (stepConditions[\"u\"]*D)/nu\n            Pr = bht.air_Pr()\n            k = bht.air_k(T_film)\n            Nu_forced = ht.conv_external.Nu_external_cylinder(Re,Pr)\n            h_forced = Nu_forced*(k/D)\n        else:\n            h_forced = 0.\n\n        var[\"h_back_tube\"] = (res**3 + h_forced**3)**(1/3)\n</code></pre>"},{"location":"model_ht/#model_ht.h_fluid","title":"<code>h_fluid(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the convective heat transfer coefficient between the fluid and the tube wall and stores it in var[\"h_fluid\"]</p> <ul> <li>If the exchanger is a flow distribution like, the considered flow rate value is the total flow rate in the PVT divided by 2 (because the flow is distributed/collected to/form the channels all along the manifold)</li> <li>If the Re &lt; 2000, the Nusselt number is calculated with the Shan-London correlation for laminar flow in a rectangular duct or with the 'Laminar - constant Q' method for a circular duct</li> <li>If the Re &gt;= 2000, the Nusselt number is calculated with the Colburn correlation for turbulent flow</li> </ul> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters of the PVT panel</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_fluid(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the convective heat transfer coefficient between the fluid and the tube wall and stores it in var[\"h_fluid\"]\n\n    - If the exchanger is a flow distribution like, the considered flow rate value is the total flow rate in the PVT divided by 2 (because the flow is distributed/collected to/form the channels all along the manifold)\n    - If the Re &lt; 2000, the Nusselt number is calculated with the Shan-London correlation for laminar flow in a rectangular duct or with the 'Laminar - constant Q' method for a circular duct\n    - If the Re &gt;= 2000, the Nusselt number is calculated with the Colburn correlation for turbulent flow\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters of the PVT panel\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\n    \"\"\"\n\n    D_tube = componentSpecs[\"D_tube\"]\n    L_tube = componentSpecs[\"L_tube\"]\n\n    if (componentSpecs[\"is_inlet_man\"] == 1 or componentSpecs[\"is_outlet_man\"] == 1) and componentSpecs[\"geometry\"] == \"harp\":\n        mdot = stepConditions[\"mdot\"]/2\n    else:\n        mdot = stepConditions[\"mdot\"]\n\n    N_harp = componentSpecs[\"N_harp\"]\n\n    T_fluid = stepConditions[\"T_fluid_in0\"]\n\n    p_fluid = hyp[\"p_fluid\"]\n    fluid = hyp[\"fluid\"]\n    glycol_rate = hyp[\"glycol_rate\"]\n\n    k_fluid = PropsSI('L', 'P', p_fluid, 'T', T_fluid, f'INCOMP::{fluid}[{glycol_rate}]')\n    rho_fluid = PropsSI('D', 'P', p_fluid, 'T', T_fluid, f'INCOMP::{fluid}[{glycol_rate}]')\n    mu_fluid = PropsSI('V', 'P', p_fluid, 'T', T_fluid, f'INCOMP::{fluid}[{glycol_rate}]')\n    Pr = PropsSI('Prandtl', 'P', p_fluid, 'T', T_fluid, f'INCOMP::{fluid}[{glycol_rate}]')\n\n    flow_rate_per_riser = (mdot/N_harp)/rho_fluid # en m3/s\n    tube_section = math.pi*(D_tube/2)**2\n\n    fluid_speed = flow_rate_per_riser/tube_section\n\n    Re = (rho_fluid*fluid_speed*D_tube)/mu_fluid\n\n    if Re &lt; 2000:\n        if componentSpecs[\"tube_geometry\"] == \"rectangular\":\n            Nu = ht.conv_internal.Nu_laminar_rectangular_Shan_London(min(componentSpecs[\"H_tube\"],componentSpecs[\"w_tube\"])/max(componentSpecs[\"H_tube\"],componentSpecs[\"w_tube\"]))\n        else:\n            Nu = ht.conv_internal.Nu_conv_internal(Re,Pr,Method='Laminar - constant Q')\n    else:\n        Nu = ht.conv_internal.turbulent_Colburn(Re,Pr)\n\n    var[\"Re\"] = Re\n    var[\"Nu\"] = Nu\n    var[\"h_fluid\"]  = (k_fluid/D_tube)*Nu\n</code></pre>"},{"location":"model_ht/#model_ht.h_rad","title":"<code>h_rad(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the radiation heat transfer coefficient and stores it in var[\"h_rad\"]</p> <p>$$ h_{rad} = \\epsilon \\sigma (T_{PV}+T_{sky})(T_{PV}^2+T_{sky}^2) $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_rad(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the radiation heat transfer coefficient and stores it in var[\"h_rad\"]\n\n    $$\n    h_{rad} = \\epsilon \\sigma (T_{PV}+T_{sky})(T_{PV}^2+T_{sky}^2)\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\"\"\"\n\n    eps = componentSpecs[\"eps_PV\"]\n    sigma = hyp[\"sigma\"]\n    T_sky = stepConditions[\"T_sky\"]\n\n    T_PV = var[\"T_PV\"]\n\n    tau_g_IR = componentSpecs[\"tau_g_IR\"]\n\n    h = tau_g_IR*eps*sigma*(T_PV+T_sky)*(T_PV**2+T_sky**2)\n    var[\"h_rad\"]=h\n</code></pre>"},{"location":"model_ht/#model_ht.h_rad_back","title":"<code>h_rad_back(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the radiation heat transfer coefficient between the absorber and the ambient air and stores it in var[\"h_rad_back\"]</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_rad_back(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the radiation heat transfer coefficient between the absorber and the ambient air and stores it in var[\"h_rad_back\"]\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\n    \"\"\"\n\n    if hyp['method_h_back_abs'] == 'CFD':\n        var[\"h_rad_back\"]=1e-10\n        return\n\n    sigma = hyp[\"sigma\"]\n    T_back_rad = stepConditions[\"T_back\"] # hypoth\u00e8se T_amb = T_back   \n    if componentSpecs[\"insulated\"] == 1:\n        T_ref = var[\"T_ins_mean\"]\n        eps = componentSpecs[\"eps_ins\"]\n    else: \n        T_ref = var[\"T_abs_mean\"]\n        eps = componentSpecs[\"eps_hx_back\"]\n\n    T_back_rad_changed = hyp[\"T_back_rad_changed\"]\n\n    if T_back_rad_changed &gt; 0:\n        T_back_rad_changed += 273.15\n        sigma = hyp[\"sigma\"]\n\n        h2 = eps*sigma*(T_ref+T_back_rad_changed)*(T_ref**2+T_back_rad_changed**2)\n        h1 = (h2*T_back_rad_changed)/T_back_rad\n    else:\n        h1 = eps*sigma*(T_ref+T_back_rad)*(T_ref**2+T_back_rad**2)\n\n    var[\"h_rad_back\"]=h1\n</code></pre>"},{"location":"model_ht/#model_ht.h_rad_back_tube","title":"<code>h_rad_back_tube(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the radiation heat transfer coefficient between the tube and the ambient air and stores it in var[\"h_rad_back_tube\"]</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_rad_back_tube(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the radiation heat transfer coefficient between the tube and the ambient air and stores it in var[\"h_rad_back_tube\"]\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\n    \"\"\"\n\n    if hyp['method_h_rad_back_tube'] == 'CFD':\n        var[\"h_rad_back_tube\"]=1e-10\n        return\n\n    sigma = hyp[\"sigma\"]\n    T_back_rad = stepConditions[\"T_back\"] # hypoth\u00e8se T_amb = T_back   \n    if componentSpecs[\"insulated\"] == 1 and stepConditions[\"compt\"] &gt;= 1:\n        T_ref = var[\"T_ins_tube_mean\"]\n        eps = componentSpecs[\"eps_ins\"]\n    else: \n        T_ref = var[\"T_tube_mean\"]\n        eps = componentSpecs[\"eps_hx_back\"]\n\n    h = eps*sigma*(T_ref+T_back_rad)*(T_ref**2+T_back_rad**2)\n    var[\"h_rad_back_tube\"]=h\n</code></pre>"},{"location":"model_ht/#model_ht.h_rad_g","title":"<code>h_rad_g(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the radiative heat transfer coefficient between the glass and the sky and stores it in var[\"h_rad_g\"]</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters of the PVT panel</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_rad_g(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the radiative heat transfer coefficient between the glass and the sky and stores it in var[\"h_rad_g\"]\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters of the PVT panel\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\"\"\"\n    if hyp['method_h_top_g_exchanger'] == 'CFD':\n        var[\"h_rad_g\"]=1e-10\n    else :\n        var[\"h_rad_g\"] = bht.h_rad(componentSpecs[\"eps_g\"],var[\"T_glass\"],stepConditions[\"T_sky\"])\n</code></pre>"},{"location":"model_ht/#model_ht.h_rad_tube_abs","title":"<code>h_rad_tube_abs(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the radiation heat transfer coefficient between the tube and the absorber and stores it in var[\"h_rad_tube_abs\"]</p> <p>If the tube is in contact with the absorber, it is set to 0 (conduction only). Otherwise, it is calculated as follows:</p> <p>$$h_{rad,f} = \\epsilon_{hx} \\sigma (T_{tube}+T_{abs})(T_{tube}^2+T_{abs}^2)$$</p> <p>A multiplying factor is optional in hypotheses file as \"coeff_h_rad_tube_abs\"</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_rad_tube_abs(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the radiation heat transfer coefficient between the tube and the absorber and stores it in var[\"h_rad_tube_abs\"]\n\n    If the tube is in contact with the absorber, it is set to 0 (conduction only). Otherwise, it is calculated as follows:\n\n    $$h_{rad,f} = \\epsilon_{hx} \\sigma (T_{tube}+T_{abs})(T_{tube}^2+T_{abs}^2)$$\n\n    A multiplying factor is optional in hypotheses file as \"coeff_h_rad_tube_abs\"\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\n    \"\"\"\n\n    if componentSpecs[\"l_c\"] &gt; 0. :\n        h=0.\n\n    elif hyp['method_h_back_tube'] == 'CFD':\n        h=0.\n\n    else:\n\n        sigma = hyp[\"sigma\"]\n\n        T_ref = var[\"T_tube_mean\"]\n        T_B = var[\"T_Base_mean\"]\n\n        eps = componentSpecs[\"eps_hx_top\"]\n\n        h = eps*sigma*(T_ref+T_B)*(T_ref**2+T_B**2)\n\n    var[\"h_rad_tube_abs\"] = hyp[\"coeff_h_rad_tube_abs\"]*h\n</code></pre>"},{"location":"model_ht/#model_ht.h_rad_tube_sky","title":"<code>h_rad_tube_sky(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the radiative heat transfer coefficient between the tube and the sky and stores it in var[\"h_rad_tube_sky\"]</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters of the PVT panel</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_rad_tube_sky(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the radiative heat transfer coefficient between the tube and the sky and stores it in var[\"h_rad_tube_sky\"]\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters of the PVT panel\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\n    \"\"\"\n    eps = componentSpecs[\"eps_hx_top\"]\n    sigma = hyp[\"sigma\"]\n    T_sky = stepConditions[\"T_sky\"]\n\n    T_tube = var[\"T_tube_mean\"]\n\n    tau_g_IR = componentSpecs[\"tau_g_IR\"]\n\n    h = tau_g_IR * eps*sigma*(T_tube+T_sky)*(T_tube**2+T_sky**2)\n\n    var[\"h_rad_tube_sky\"]=h\n</code></pre>"},{"location":"model_ht/#model_ht.h_top_g","title":"<code>h_top_g(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the convective heat transfer coefficient between the top of the panel (glass) and the ambient air and stores it in var[\"h_top_g\"]</p> <ul> <li> <p>If the component is a manifold:</p> <ul> <li>If the method is 'like_exchanger', the coefficient is the same as the one found when solving the 'main'</li> </ul> </li> <li> <p>If the component is a heat exchanger part:</p> <ul> <li> <p>These coefficients are computed :</p> <ul> <li>$h_{free}$ = top_h_simple(...)</li> <li>$h_{forced_turbulent}$ = h_top_forced_turbulent(...)</li> <li>$h_{forced}$ = h_top_forced(...)</li> <li>$h_{custom}$ = h_top_custom(...)</li> </ul> </li> <li> <p>If the method is 'free_with_coeff', the coefficient is the free convection coefficient multiplied by a coefficient</p> </li> <li>If the method is 'free', the coefficient is the free convection coefficient</li> <li>If the method is 'forced_turbulent_with_coeff', the coefficient is the forced convection coefficient in the turbulent regime multiplied by a coefficient</li> <li>If the method is 'forced_turbulent', the coefficient is the forced convection coefficient in the turbulent regime</li> <li>If the method is 'forced_with_coeff', the coefficient is the forced convection coefficient multiplied by a coefficient</li> <li>If the method is 'forced', the coefficient is the forced convection coefficient</li> <li>If the method is 'free_forced_with_coeff', the coefficient is the free convection coefficient multiplied by a coefficient if the wind speed is lower than 0.1 m/s, otherwise it is the forced convection coefficient multiplied by a coefficient</li> <li>If the method is 'mixed_with_coeff', the coefficient is the cubic mean of the free convection coefficient and the forced convection coefficient multiplied by a coefficient</li> <li>If the method is 'mixed', the coefficient is the cubic mean of the free convection coefficient and the forced convection coefficient</li> <li>If the method is 'custom', the coefficient is the custom convection coefficient</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters of the PVT panel</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_top_g(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the convective heat transfer coefficient between the top of the panel (glass) and the ambient air and stores it in var[\"h_top_g\"]\n\n    - If the component is a manifold:\n        - If the method is 'like_exchanger', the coefficient is the same as the one found when solving the 'main'\n\n    - If the component is a heat exchanger part:\n\n        - These coefficients are computed :\n\n            - $h_{free}$ = top_h_simple(...)\n            - $h_{forced_turbulent}$ = h_top_forced_turbulent(...)\n            - $h_{forced}$ = h_top_forced(...)\n            - $h_{custom}$ = h_top_custom(...)\n\n        - If the method is 'free_with_coeff', the coefficient is the free convection coefficient multiplied by a coefficient\n        - If the method is 'free', the coefficient is the free convection coefficient\n        - If the method is 'forced_turbulent_with_coeff', the coefficient is the forced convection coefficient in the turbulent regime multiplied by a coefficient\n        - If the method is 'forced_turbulent', the coefficient is the forced convection coefficient in the turbulent regime\n        - If the method is 'forced_with_coeff', the coefficient is the forced convection coefficient multiplied by a coefficient\n        - If the method is 'forced', the coefficient is the forced convection coefficient\n        - If the method is 'free_forced_with_coeff', the coefficient is the free convection coefficient multiplied by a coefficient if the wind speed is lower than 0.1 m/s, otherwise it is the forced convection coefficient multiplied by a coefficient\n        - If the method is 'mixed_with_coeff', the coefficient is the cubic mean of the free convection coefficient and the forced convection coefficient multiplied by a coefficient\n        - If the method is 'mixed', the coefficient is the cubic mean of the free convection coefficient and the forced convection coefficient\n        - If the method is 'custom', the coefficient is the custom convection coefficient\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters of the PVT panel\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\"\"\"\n\n    if hyp['method_h_top_g_exchanger'] == 'CFD':\n        get_CFD_value(componentSpecs, stepConditions, var, hyp, 'h_top_g', 'phi_top', 'T_glass', 'T_amb')\n        return\n\n    # Manifold\n    if componentSpecs[\"is_inlet_man\"] == 1 or componentSpecs[\"is_outlet_man\"] == 1:\n        if hyp['method_h_top_g_manifold'] == 'like_exchanger':\n            var['h_top_g'] = hyp['h_top_man']\n        else:\n            raise ValueError(\"Method for h_top_g is not well defined for manifolds\")\n\n    # Heat exchanger\n    else:\n        T_glass = var[\"T_glass\"]\n        T_amb = stepConditions[\"T_amb\"]\n\n        if componentSpecs[\"orientation\"]==\"portrait\":\n            L_c = componentSpecs[\"L_pan\"]\n        else:\n            L_c = componentSpecs[\"w_pan\"]\n\n        h_free = bht.top_h_simple(T_glass,T_amb,hyp[\"theta\"],L_c)\n        h_forced_turbulent = bht.h_top_forced_turbulent(T_glass,T_amb,stepConditions[\"u\"],L_c)\n        h_forced = bht.h_top_forced(T_glass,T_amb,stepConditions[\"u\"],L_c)\n        h_custom = bht.h_top_custom(T_glass,T_amb,stepConditions[\"u\"],L_c)\n\n        if hyp['method_h_top_g_exchanger'] == 'free_with_coeff':\n            var[\"h_top_g\"] = hyp[\"coeff_h_top_free\"]*h_free\n        elif hyp['method_h_top_g_exchanger'] == 'free':\n            var[\"h_top_g\"] = h_free\n        elif hyp['method_h_top_g_exchanger'] == 'forced_turbulent_with_coeff':\n            h_forced = hyp[\"coeff_h_top_forced\"]*h_forced_turbulent\n        elif hyp['method_h_top_g_exchanger'] == 'forced_turbulent':\n            var[\"h_top_g\"] = h_forced_turbulent\n        elif hyp['method_h_top_g_exchanger'] == 'forced_with_coeff':\n            var[\"h_top_g\"] = hyp[\"coeff_h_top_forced\"]*h_forced\n        elif hyp['method_h_top_g_exchanger'] == 'forced':\n            var[\"h_top_g\"] = h_forced\n        elif hyp['method_h_top_g_exchanger'] == 'free_forced_with_coeff':\n            if stepConditions['u'] &lt; 0.1:\n                var[\"h_top_g\"] = hyp[\"coeff_h_top_free\"]*h_free\n            else:\n                var[\"h_top_g\"] = hyp[\"coeff_h_top_forced\"]*h_forced\n        elif hyp['method_h_top_g_exchanger'] == 'mixed_with_coeff':\n            var[\"h_top_g\"] = ( (hyp[\"coeff_h_top_free\"]*h_free)**3 + (hyp[\"coeff_h_top_forced\"]*h_forced)**3 )**(1/3)\n        elif hyp['method_h_top_g_exchanger'] == 'mixed':\n            var[\"h_top_g\"] = (h_free**3 + h_forced**3)**(1/3)\n        elif hyp['method_h_top_g_exchanger'] == 'custom':\n            var[\"h_top_g\"] = h_custom\n        else:\n            raise ValueError(\"Method for h_top_g is not well defined for exchanger\")\n</code></pre>"},{"location":"model_ht/#model_ht.h_top_mean","title":"<code>h_top_mean(componentSpecs, stepConditions, var, hyp)</code>","text":"<p>Calculates the mean h_top between the value at iteration n-1 and the value calculated at iteration n and stores it in var[\"h_top_g\"]</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the PVT parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <code>hyp</code> <code>dict</code> <p>dictionary containing the hypotheses</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_ht.py</code> <pre><code>def h_top_mean(componentSpecs,stepConditions,var,hyp):\n    \"\"\"Calculates the mean h_top between the value at iteration n-1 and the value calculated at iteration n and stores it in var[\"h_top_g\"]\n\n    Args:\n        componentSpecs (dict): dictionary containing the PVT parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n        hyp (dict): dictionary containing the hypotheses\n\n    Returns:\n        None\"\"\"\n\n    old_h_top = var[\"h_top_g\"]\n    h_top_g(componentSpecs,stepConditions,var,hyp)\n\n    new_h_top = var[\"h_top_g\"]\n\n    var[\"h_top_g\"] = (old_h_top+new_h_top)/2\n</code></pre>"},{"location":"model_temperatures/","title":"Model temperatures","text":""},{"location":"model_temperatures/#model_temperatures.T_Base_mean","title":"<code>T_Base_mean(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the mean base temperature and stores it in var[\"T_Base_mean\"]</p> <p>$$ T_{Base,mean} = \frac{q_{tube,fluid}}{C_B+h_{rad,f}p_{ext,tube,rad}} + T_{fluid,mean} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_temperatures.py</code> <pre><code>def T_Base_mean(componentSpecs, stepConditions,var): #T_fluid has already been used for q_f_p and T_f_mean calculations\n    \"\"\"Calculates the mean base temperature and stores it in var[\"T_Base_mean\"]\n\n    $$\n    T_{Base,mean} = \\frac{q_{tube,fluid}}{C_B+h_{rad,f}p_{ext,tube,rad}} + T_{fluid,mean}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n    # C_B = componentSpecs[\"C_B\"]\n\n    # p_int_tube = componentSpecs[\"p_int_tube\"]\n    # h_fluid = var[\"h_fluid\"]\n    # chi = 1/(h_fluid*p_int_tube)\n\n    # h_back = var[\"h_back\"]+var[\"h_rad_back\"]\n    # p_ext_tube = componentSpecs[\"p_ext_tube\"];p_ext_tube_rad = componentSpecs[\"p_ext_tube_rad\"]\n    # R_2 = componentSpecs[\"R_2\"]\n    # gamma_back = p_ext_tube/(R_2+1/h_back)\n    # gamma_0_int = var[\"gamma_0_int\"]\n    # gamma_1_int = var[\"gamma_1_int\"]\n    # gamma = gamma_back + gamma_0_int + gamma_1_int\n\n    # h_rad_tube_abs = var[\"h_rad_tube_abs\"]\n\n    # e0 = var[\"e0\"]\n    T_fluid = var[\"T_fluid_mean\"]\n    q_tube_fluid = var[\"q_tube_fluid\"]\n    T_back = stepConditions[\"T_back\"]\n    T_sky = stepConditions[\"T_sky\"]\n\n    # res = (1/(C_B+h_rad_tube_abs))*(e0*q_tube_fluid - (1/chi)*T_fluid - gamma*T_back)\n    # var[\"T_Base_mean\"] = res\n\n    # res = (1/(h_fluid*p_int_tube)+1/C_B)*q_tube_fluid + T_f_mean\n\n    b1 = var[\"b1\"]\n    b2 = var[\"b2\"]\n    b3 = var[\"b3\"]\n    b4 = var[\"b4\"]\n\n    res = b1*q_tube_fluid + b2*T_fluid + b3*T_back + b4*T_sky\n    var[\"T_Base_mean\"] = res\n</code></pre>"},{"location":"model_temperatures/#model_temperatures.T_PV_mean","title":"<code>T_PV_mean(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the mean PV temperature and stores it in var[\"T_PV_mean\"]</p> <p>$$ T_{PV,mean} = \frac{1}{\u0007lpha_{PV}}\\left(\u0007lpha_{PV}T_{abs,mean} + h_{rad}T_{sky} + \frac{T_{abs,mean}}{R_{inter}} ight) $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_temperatures.py</code> <pre><code>def T_PV_mean(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the mean PV temperature and stores it in var[\"T_PV_mean\"]\n\n    $$\n    T_{PV,mean} = \\frac{1}{\\alpha_{PV}}\\left(\\alpha_{PV}T_{abs,mean} + h_{rad}T_{sky} + \\frac{T_{abs,mean}}{R_{inter}}\\right)\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    R_inter = componentSpecs[\"R_inter\"]\n    T_sky = stepConditions[\"T_sky\"]\n\n    h_rad = var[\"h_rad\"]\n    S = var[\"S\"]\n    Fprime = var[\"Fp\"]\n    a2 = var[\"a2\"]\n    T_abs_mean = var[\"T_abs_mean\"]\n\n    res = Fprime*R_inter*(S-a2+h_rad*T_sky+(T_abs_mean/R_inter))\n\n    var[\"T_PV0\"] = var[\"T_PV\"]\n    var[\"T_PV\"] = res\n</code></pre>"},{"location":"model_temperatures/#model_temperatures.T_abs_mean","title":"<code>T_abs_mean(componentSpecs, var)</code>","text":"<p>Calculates the mean absorber temperature and stores it in var[\"T_abs_mean\"]</p> <p>$$ T_{abs,mean} = \frac{l_B T_{Base,mean}+2L_{af}T_{abs,fin,mean}}{W} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_temperatures.py</code> <pre><code>def T_abs_mean(componentSpecs,var):\n    \"\"\"Calculates the mean absorber temperature and stores it in var[\"T_abs_mean\"]\n\n    $$\n    T_{abs,mean} = \\frac{l_B T_{Base,mean}+2L_{af}T_{abs,fin,mean}}{W}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n    W = componentSpecs[\"W\"]\n    l_B = componentSpecs[\"l_B\"]\n    L_af = componentSpecs[\"L_af\"]\n\n    T_Base_mean = var[\"T_Base_mean\"]\n    T_absfin_mean = var[\"T_absfin_mean\"]\n\n    res = (l_B*T_Base_mean+(L_af*2)*T_absfin_mean)/W\n    var[\"T_abs_mean\"] = res\n</code></pre>"},{"location":"model_temperatures/#model_temperatures.T_absfin_mean","title":"<code>T_absfin_mean(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the mean fin temperature and stores it in var[\"T_absfin_mean\"]</p> <p>$$ T_{abs,fin,mean} = \frac{b}{j} + \\left(T_{Base,mean}-\frac{b}{j} ight)\frac{      anh(mL_{af})}{mL_{af}} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_temperatures.py</code> <pre><code>def T_absfin_mean(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the mean fin temperature and stores it in var[\"T_absfin_mean\"]\n\n    $$\n    T_{abs,fin,mean} = \\frac{b}{j} + \\left(T_{Base,mean}-\\frac{b}{j}\\right)\\frac{\\tanh(mL_{af})}{mL_{af}}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n    W = componentSpecs[\"W\"]\n    L_af = componentSpecs[\"L_af\"]\n\n    S = var[\"S\"]\n\n    b = var[\"b\"]\n    j = var[\"j\"]\n    m = var[\"m\"]\n\n    T_B_mean = var[\"T_Base_mean\"]\n\n    var[\"T_absfin_mean\"] = b/j + (T_B_mean-(b/j))*math.tanh(m*L_af)/(m*L_af)\n</code></pre>"},{"location":"model_temperatures/#model_temperatures.T_fluid_mean","title":"<code>T_fluid_mean(componentSpecs, var)</code>","text":"<p>Calculates the mean fluid temperature and stores it in var[\"T_fluid_mean\"]</p> <p>$$ T_{fluid,mean} = \frac{T_{fluid,in}+\frac{b_f}{a_f}}{a_fL_{tube}}e^{a_fL_{tube}} - \frac{b_f}{a_fL_{tube}} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>T_fluid_in</code> <code>float</code> <p>fluid inlet temperature</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_temperatures.py</code> <pre><code>def T_fluid_mean(componentSpecs,var):\n    \"\"\"Calculates the mean fluid temperature and stores it in var[\"T_fluid_mean\"]\n\n    $$\n    T_{fluid,mean} = \\frac{T_{fluid,in}+\\frac{b_f}{a_f}}{a_fL_{tube}}e^{a_fL_{tube}} - \\frac{b_f}{a_fL_{tube}}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        T_fluid_in (float): fluid inlet temperature\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n\n    L_tube = componentSpecs[\"L_tube\"]\n\n    T_fluid_in = var['T_fluid_in']\n\n    h_back_tube = var[\"h_back_tube\"]\n    if h_back_tube == None:\n        print(var[\"T_tube_mean\"])\n        h_back_tube = 3.\n\n    a = var[\"a_f\"]\n    b = var[\"b_f\"]\n\n    res = ((T_fluid_in+(b/a))/(a*L_tube))*math.exp(a*L_tube) - (T_fluid_in+(b/a))/(a*L_tube) - b/a\n    var[\"T_fluid_mean\"] = res\n</code></pre>"},{"location":"model_temperatures/#model_temperatures.T_fluid_out","title":"<code>T_fluid_out(componentSpecs, var)</code>","text":"<p>Calculates the fluid outlet temperature and stores it in var[\"T_fluid_out\"]</p> <p>$$ T_{fluid,out} = (T_{fluid,in}+\frac{b_f}{a_f})e^{a_fL_{tube}} - \frac{b_f}{a_f} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>T_fluid_in</code> <code>float</code> <p>fluid inlet temperature</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_temperatures.py</code> <pre><code>def T_fluid_out(componentSpecs,var):\n    \"\"\"Calculates the fluid outlet temperature and stores it in var[\"T_fluid_out\"]\n\n    $$\n    T_{fluid,out} = (T_{fluid,in}+\\frac{b_f}{a_f})e^{a_fL_{tube}} - \\frac{b_f}{a_f}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        T_fluid_in (float): fluid inlet temperature\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\n    \"\"\"\n\n    a = var[\"a_f\"]\n    b = var[\"b_f\"]\n\n    L_tube = componentSpecs[\"L_tube\"]\n\n    T_fluid_in = var['T_fluid_in']\n\n    res = (T_fluid_in+(b/a))*math.exp(a*L_tube) - b/a\n    var[\"T_fluid_out\"] = res\n</code></pre>"},{"location":"model_temperatures/#model_temperatures.T_glass_mean","title":"<code>T_glass_mean(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the mean glass temperature and stores it in var[\"T_glass_mean\"]</p> <p>$$ T_{glass,mean} = \frac{1}{\u0007lpha_g}\\left(\u0007lpha_gT_{PV} + h_{top,g}T_{amb} + h_{rad,g}T_{sky} + \frac{T_{PV}}{R_g} ight) $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_temperatures.py</code> <pre><code>def T_glass_mean(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the mean glass temperature and stores it in var[\"T_glass_mean\"]\n\n    $$\n    T_{glass,mean} = \\frac{1}{\\alpha_g}\\left(\\alpha_gT_{PV} + h_{top,g}T_{amb} + h_{rad,g}T_{sky} + \\frac{T_{PV}}{R_g}\\right)\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n    alpha = componentSpecs[\"alpha_g\"]\n\n    h_top_g = var[\"h_top_g\"]\n    h_rad_g = var[\"h_rad_g\"]\n    R_g = componentSpecs[\"R_g\"]\n    G = stepConditions[\"G\"]\n    T_amb = stepConditions[\"T_amb\"]\n    T_sky = stepConditions[\"T_sky\"]\n    T_PV = var[\"T_PV\"]\n\n    res = (1/(h_top_g+h_rad_g+(1/R_g)))*(alpha*G + h_top_g * T_amb + h_rad_g * T_sky + (1/R_g)*T_PV)\n\n    var[\"T_glass\"] = res\n</code></pre>"},{"location":"model_temperatures/#model_temperatures.T_tube_mean","title":"<code>T_tube_mean(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the mean tube temperature and stores it in var[\"T_tube_mean\"]</p> <p>$$ T_{tube,mean} = e_1T_{Base,mean} + e_2T_{fluid,mean} + e_3T_{back} + e_4T_{sky} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_temperatures.py</code> <pre><code>def T_tube_mean(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the mean tube temperature and stores it in var[\"T_tube_mean\"]\n\n    $$\n    T_{tube,mean} = e_1T_{Base,mean} + e_2T_{fluid,mean} + e_3T_{back} + e_4T_{sky}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n    e1 = var[\"e1\"]\n    e2 = var[\"e2\"]\n    e3 = var[\"e3\"]\n    e4 = var[\"e4\"]\n\n    T_B = var[\"T_Base_mean\"]\n    T_fluid = var[\"T_fluid_mean\"]\n    T_back = stepConditions[\"T_back\"]\n    T_sky = stepConditions[\"T_sky\"]\n\n    var[\"T_tube_mean\"] = e1*T_B + e2*T_fluid + e3*T_back + e4*T_sky\n</code></pre>"},{"location":"model_transfers/","title":"Model transfers","text":""},{"location":"model_transfers/#model_transfers.q_Base_tube","title":"<code>q_Base_tube(componentSpecs, var)</code>","text":"<p>Calculates the heat flux from the base to the tube and stores it in var[\"q_Base_tube\"]</p> <p>$$ q_{Base,tube} = -   heta_{Bt}q_{tube,fluid} + \\kappa_{Bt}T_{fluid,out} + \\epsilon_{Bt} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_transfers.py</code> <pre><code>def q_Base_tube(componentSpecs,var):\n    \"\"\"Calculates the heat flux from the base to the tube and stores it in var[\"q_Base_tube\"]\n\n    $$\n    q_{Base,tube} = -\\theta_{Bt}q_{tube,fluid} + \\kappa_{Bt}T_{fluid,out} + \\epsilon_{Bt}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n    Ka_Bt = var[\"Ka_Bt\"]\n    Th_Bt = var[\"Th_Bt\"]\n    Ep_Bt = var[\"Ep_Bt\"]\n\n    T_fluid = var[\"T_fluid_mean\"]\n\n    q_tube_fluid = var[\"q_tube_fluid\"]\n\n    var[\"q_Base_tube\"] = -Th_Bt*q_tube_fluid + Ka_Bt*T_fluid + Ep_Bt\n</code></pre>"},{"location":"model_transfers/#model_transfers.q_tube_fluid","title":"<code>q_tube_fluid(componentSpecs, stepConditions, var)</code>","text":"<p>Calculates the heat flux from the fluid to the tube and stores it in var[\"q_tube_fluid\"]</p> <p>$$ q_{tube,fluid} = \frac{\\dot{m}C_p(T_{fluid,out}-T_{fluid,in})}{L_{tube}N_{harp}} $$</p> <p>Parameters:</p> Name Type Description Default <code>componentSpecs</code> <code>dict</code> <p>dictionary containing the parameters</p> required <code>stepConditions</code> <code>dict</code> <p>dictionary containing the meteo inputs</p> required <code>T_fluid_in</code> <code>float</code> <p>fluid inlet temperature</p> required <code>var</code> <code>dict</code> <p>dictionary containing the variables</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>model_transfers.py</code> <pre><code>def q_tube_fluid(componentSpecs,stepConditions,var):\n    \"\"\"Calculates the heat flux from the fluid to the tube and stores it in var[\"q_tube_fluid\"]\n\n    $$\n    q_{tube,fluid} = \\frac{\\dot{m}C_p(T_{fluid,out}-T_{fluid,in})}{L_{tube}N_{harp}}\n    $$\n\n    Args:\n        componentSpecs (dict): dictionary containing the parameters\n        stepConditions (dict): dictionary containing the meteo inputs\n        T_fluid_in (float): fluid inlet temperature\n        var (dict): dictionary containing the variables\n\n    Returns:\n        None\"\"\"\n    N_harp = componentSpecs[\"N_harp\"]\n    L = componentSpecs[\"L_tube\"]\n    mdot = stepConditions[\"mdot\"]\n    Cp = var[\"Cp\"]    \n\n    T_fluid_in = var[\"T_fluid_in\"]\n\n    T_f_out = var[\"T_fluid_out\"]\n    res = (mdot*Cp*(T_f_out-T_fluid_in))/(L*N_harp)\n\n    var[\"q_tube_fluid\"] = res\n</code></pre>"},{"location":"mpe_model/","title":"Model MPE","text":""},{"location":"plot_functions_here/","title":"Plot functions","text":""},{"location":"proc/","title":"Proc","text":""},{"location":"test/","title":"Tests","text":""},{"location":"test/#another-heading","title":"Another heading","text":"<p>some more example text</p>"},{"location":"test/#codeblocks","title":"Codeblocks","text":"<p>Some <code>code</code> goes here.</p>"},{"location":"test/#plain-codeblock","title":"Plain codeblock","text":"<pre><code>def myfunction() :\n// comments\n</code></pre>"},{"location":"test/#code-for-a-specific-language","title":"Code for a specific language","text":"<p>Some more code with th <code>py</code> at the start : </p> <pre><code>import tensorflow as tf\ndef function()\n</code></pre>"},{"location":"test/#code-with-title","title":"Code with title","text":"<p><code>py title=\"title_main.py\" def title_main(n) :     for i in range(n) :     # comments    break</code></p>"},{"location":"test/#code-with-linenums","title":"Code with linenums","text":"<p><code>py linenums = \"1\" def title_main(n) :     for i in range(n) :     # comments     break</code></p>"},{"location":"test/#code-with-highlighted-lines","title":"Code with highlighted lines","text":"<p><code>py hl_lines = \"2 3\"  def title_main(n) :      for i in range(n) :      # comments      break</code></p>"}]}